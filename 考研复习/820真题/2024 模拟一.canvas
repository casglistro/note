{
	"nodes":[
		{"id":"64c4801872a8a526","type":"group","x":-2440,"y":-1560,"width":3080,"height":2480,"color":"4","label":"2024第一套"},
		{"id":"3418738c6de7e66f","type":"group","x":-2440,"y":2660,"width":1980,"height":1580,"color":"4","label":"24第三套"},
		{"id":"31ef8281bad91a8e","type":"group","x":-2120,"y":-1280,"width":2200,"height":1320,"color":"3","label":"Os"},
		{"id":"79ba5cc4294d2c5d","type":"group","x":-2440,"y":1120,"width":1840,"height":1320,"color":"4","label":"2024第二套"},
		{"id":"6a3c74bc433230ce","type":"group","x":-2040,"y":-1200,"width":1020,"height":1140,"color":"1","label":"选填"},
		{"id":"efb575d568793681","type":"group","x":-2120,"y":80,"width":1480,"height":620,"color":"4","label":"Ds"},
		{"id":"a6527e096f823f88","type":"group","x":-2380,"y":1180,"width":1140,"height":780,"color":"1","label":"Os选填"},
		{"id":"2276cee81c211dcf","type":"group","x":-2080,"y":140,"width":630,"height":420,"color":"2","label":"选填"},
		{"id":"1db63a21b54cd8b9","type":"text","text":"AOE 的关键活动是那些最早开始时间和最晚结束时间相同的活动.\n\n无向图的极小连通子图是该图的生成树, 极大联通子图是它本身.","x":980,"y":-1560,"width":620,"height":140},
		{"id":"8408aaa6d5e892f7","type":"text","text":"在一段时间内进程要访问的页面集合如下，则在 $t$ 时刻, 工作集窗口为 $7$, 工作集为\n\n$$\n1,3,4,2,4,5,7,6,8,5,6,1(t),3,4,7,5,3,3\n$$\n工作集就是从 $t$ 时刻包括 $t$ 向前寻找 $7$ 个单位，即 $1,6,5,8,7$.","x":-2020,"y":-1180,"width":787,"height":140},
		{"id":"11844be4f173a26f","type":"text","text":"# 读写者问题的写者优先的写法\n\n`S` 用于禁止读进程, 所以读进程应该获取 `S`, 当写进程写时也要获取 `S`.\n`writecount` 用于记录写进程的数量, 但是写应当互斥.\n`wmutex` 用于写的互斥, `rmutex` 用于 `readcount` 的互斥, `wcMutex` 用于 `writecount` 的互斥.\n当第一个读进程进入时, 获取 `wmutex`, 阻止写进程, 写进程进入时获取 `S` 阻止读进程.\n\n```c\nsemaphore S = 1;\nsemophore rmutex = 1, wmutex = 1, wcMutex = 1;\n\nint readcount = 0, writecount = 0;\n\nvoid reader() {\n\twhile (1) {\n\t\tP(S);\n\t\tP(rmutex);\n\t\tif (readcount == 0) P(wmutex);\n\t\treadcount++;\n\t\tV(rmutex);\n\t\tV(S);\n\n\t\tread;\n\n\t\tP(rmutex);\n\t\treadcount--;\n\t\tif (readcount == 0) V(wmutex);\n\t\tV(rmutex);\n\t}\n}\n\nvoid writer() {\n\twhile (1) {\n\t\tP(wcMutex);\n\t\tif (writecount == 0) P(S);\n\t\twritecount++;\n\t\tV(wcMutex);\n\n\t\tP(wmutex);\n\t\twrite;\n\t\tV(wmutex);\n\n\t\tP(wcMutex);\n\t\twritecount--;\n\t\tif (writecount == 0) V(S);\n\t\tV(wcMutex);\n\t}\n}\n```","x":-960,"y":-1200,"width":960,"height":1220},
		{"id":"8451d0b0a8cb4395","type":"text","text":"设计一个可以在 $O(1)$ 时间内找到最值的栈.\n\n基本思想:\n\n1. 可以考虑一次入栈两个元素, 第一次入本元素, 第二次入栈内的最小元素, 这样就可以保证栈顶的元素是最小值, 出栈也一次出两个即可.\n2. 用两个栈实现, $S_{1}$ 存元素, $S_{2}$ 存最小值, 入栈时入 $S_{1}$, 有和最小值最小或者相等时也入一次 $S_{2}$, $S_{2}$ 中就是最小值, 当出栈元素和 $S_{2}$ 一样时出一次 $S_{2}$.","x":-1400,"y":140,"width":702,"height":280,"color":"1"},
		{"id":"0f9e4ef95338b01c","type":"text","text":"采用任何基于比较的算法，对 $6$ 个互相不同的整数进行排序，至少需要多少次比较.\n\n设 $m$ 是最少比较次数, $n$ 是待排序元素总数，则一定有 $m \\geq \\log_{2}(n!)$.\n\n所以 $m \\geq \\log_{2}(720)$, 即 $m = 10$.","x":-2060,"y":340,"width":590,"height":200},
		{"id":"0ef20efe704e65b7","type":"text","text":"求和为 $s$ 的连续正数序列.\n\n用双指针, 在小于等于 $s$ 的 $1..s$ 中维护 $be gin$ 和 $end$. 当窗口中元素和大于 $S$ 时增加 $be gin$, 小于时减少 $end$, 等于 $S$ 时记录答案.","x":-1400,"y":470,"width":702,"height":140},
		{"id":"ccba221c7922720d","type":"text","text":"以下哪个选项属于两级目录的优点: 解决不同用户之间文件的重名问题","x":-2020,"y":-1000,"width":360,"height":120},
		{"id":"f1cafeacfb4afb02","type":"text","text":"在记录型信号量中, 执行 `V` 操作时, 信号量值**小于等于 0**时执行唤醒原语","x":-1626,"y":-1000,"width":552,"height":120},
		{"id":"0fe0193e1c439cd7","type":"text","text":"高度为 $7$ 的平衡二叉树最少有**33**个结点.\n\n设 $f(h)$ 是高度为 $h$ 时所具有的最小结点数量, 则 $f(h)=f(h-1)+f(h-2)+1$. (高度为 $h$ 的结点最小的平衡二叉树, 它的左右子树一定是一个高度为 $h-1$ 和高度为 $h-2$ 的平衡二叉树), 同时 $f(0)=0,f(1)=1$, 递推得 $f(2)=2,f(3)=4\\dots,f(7)=33$.\n\n用单链表实现队列时, **队头**是**链头**, **队尾**就是**链表尾**.\n\n","x":-260,"y":1140,"width":960,"height":960},
		{"id":"a008bb390c67161e","type":"text","text":"设关键字序列为 $3,7,6,8,7,1,4,5,8$, 最少的交换次数.\n\n最少的交换次数需要使用**选择排序**. 所以最少的交换次数是 `5`.","x":-2060,"y":160,"width":590,"height":120},
		{"id":"8f4d34afa8aaafc6","type":"text","text":"应用程序请求操作系统服务时需要使用**访管(陷入)**指令.","x":-2020,"y":-840,"width":360,"height":100},
		{"id":"3a4c99e338804edf","type":"text","text":"多级反馈队列调度算法中每个队列采用**FCFS**算法, 只在最后一个队列使用 $RR$ 算法.","x":-2340,"y":1220,"width":500,"height":117},
		{"id":"1d63b1fb9fd06ea9","type":"text","text":"一个作业通常由几个进程组成, 几个进程共同完成一个任务, 所以作业和进程通常不是**一一对应**的.","x":-1800,"y":1220,"width":520,"height":117},
		{"id":"64f85c60cd7c778d","type":"text","text":"$n$ 个顶点的有向图, 连通分量最多有 $n$ 个, 连通分量是极大连通子图, 一个单节点也可以是一个连通分量.\n\n数据元素是数据的基本单位, 数据项是数据的最小单位\n\n稀疏矩阵一般的压缩存储方法: 三元组和伪地址法\n\n\n","x":-2380,"y":2020,"width":400,"height":260},
		{"id":"aa535b1df70f5d81","type":"text","text":"运行在内核态的操作:\n1. 设置时间片大小\n2. 关闭中断允许位\n3. **内存单元复位**\n\n编制好的通道程序存放在**内存中**, 并且来自通道的 IO 中断事件由设备管理负责.\n\nDMA 中需要设置的寄存器: 命令状态寄存器, 内存地址寄存器, 数据寄存器, 程序计数器.\n\n在多级目录中使用路径名对文件访问, 不需要用户目录名.\n\n","x":-2420,"y":2680,"width":870,"height":320},
		{"id":"ff762b4b914d8b49","type":"text","text":"数据结构的三要素: 数据的逻辑结构, 数据的物理结构, 数据的运算.\n\n一个 $8 \\times 8$ 的三对角矩阵 $A$, 则 $A[6][5]$ 在数组中的下标.\n\n三对角矩阵是除了第一行和最后一行两个元素外,每行只有三个元素, 因此前面六行全部存满 $17$ 个元素, 第 $i$ 行第一个元素的位置是 $(i,i-1)$, 因此数组的下标就是 $17$.\n\n查探法计算 $ASL$ 失败需要算空指针，而拉链法不**需要**.\n\n稀疏矩阵的压缩存储方法: 1. 三元组 2. 邻接表 3. 十字链表 4. 伪地址","x":-1420,"y":2680,"width":940,"height":320},
		{"id":"79f191584797c73d","type":"text","text":"PV 操作\n\n```c\nvoid signal(semophore S) {\n\tS += 1;\n}\n\nvoid wait(semophore S) {\n\twhile (S <= 0);\n\tS -= 1;\n}\n\n// 记录型\nvoid signal(semophore S) {\n\tS.value++;\n\n\tif (S.value <= 0) { // 因为这里先+1,所以==0时也需要唤醒\n\t\twakeup(S.L);\n\t}\n}\n\nvoid wait(semophore S) {\n\tS.value--;\n\t\n\tif (S.value < 0) {\n\t\tblock(S.L);\n\t}\n}\n```","x":-1626,"y":-840,"width":553,"height":740},
		{"id":"3293d03d30e8ff7a","type":"text","text":"文件的逻辑结构中, 记录之间的顺序和关键字无关的是**串结构**, 一般是按存入的时间先后顺序排列.\n\n顺序结构需要用户指定一个字段作为关键字, 同时需要关键字唯一.","x":-2340,"y":1380,"width":500,"height":200},
		{"id":"5603ecfe4354432f","type":"text","text":"学生甲有文件 ABC, 乙有文件 ACD, 甲的 A 和乙的 A 不是同一个文件, 甲的 C 和乙的 C，甲的 D 和乙的 D 分别是同一个文件. 画图表示一个目录组织方案.\n\n![[qq_pic_merged_1730956527439.jpg]]","x":-2420,"y":3077,"width":870,"height":743},
		{"id":"77f2a58e6a9ccf5e","type":"text","text":"设磁盘旋转速度为 $6000r/min$, 每个磁道 $100$ 扇区, 相邻磁道间平均移动时间为 $2ms$, 启动磁臂时间 $1ms$, 若某时刻磁头位于 $100$ 号, 沿着增大移动, 使用 $CSCAN$ 算法, 队列依次为 $50,90,30,120,100,40,20$, 每次请求随机读取一个扇区, 需要多少时间?\n\n总时间是**启动磁臂时间(只算一次)+寻道时间+旋转延迟 x 次数+传输时间**.\n\n$10ms$ 读一个磁道, 因此 $0.1ms$ 一个扇区, 七个扇区即 $0.7ms$.\n$100\\to 120 \\to 20 \\to 30 \\to 40 \\to 50 \\to 90$, 一共 $190$ 磁道, 寻道 $2 \\times 190=380ms$.\n旋转延迟和传输 $(\\dfrac{1}{2r}+0.1)\\times 7 =5.1\\times 7 =35.7$.\n因此总时间 $380 + 35.7 + 1 = 416.7ms$.","x":-2420,"y":3900,"width":870,"height":320},
		{"id":"e4f48d4aeb6db3ef","type":"text","text":"SCAN 算法是到头后反向查找, 而 CSCAN 才是到头后回到起点同向查找.","x":-2340,"y":1620,"width":500,"height":100},
		{"id":"4d1eea4f10e3e1f4","type":"text","text":"**中断向量**中存储的是中断服务程序的地址, 而中断向量地址存储的是中断向量的地址.","x":-1800,"y":1620,"width":520,"height":100},
		{"id":"a680853b9cad9256","type":"text","text":"磁盘 $IO$ 一次可以读几块, 因此连续的文件, 读取数据只需要**一次**即可.","x":-2340,"y":1760,"width":500,"height":120},
		{"id":"e4fc1da02410a3a2","type":"text","text":"导致进程创建的典型事件:\n\n1. 用户登录\n2. 作业调度\n3. 提供服务\n4. 应用请求","x":-1800,"y":1380,"width":520,"height":200},
		{"id":"83a8db550f00594f","type":"text","text":"在具有快表机制的请求分页存储系统中, 访问一次内存需要 $3\\mu s$, 查询一次快表 $0.1\\mu s$, 缺页处理 $1ms$, 快表命中率 $70\\%$, 未命中快表缺页率 $10\\%$, 则有效访问时间是 $34.003ms$\n\n命中快表: $0.7\\times 3.1$.\n命中未缺页 $0.3\\times 0.9 \\times 6.1$\n命中且缺页 $0.3\\times 0.1 \\times(0.1+3+100+0.1+3)$\n\n**命中且缺页时, 先访问快表, 然后访问内存, 缺页处理, 处理后再命中快表, 再访问内存**.\n\n一共需要访问**2**次内存,**2**存快表, 一次缺页处理.","x":-2420,"y":4640,"width":870,"height":360,"color":"1"}
	],
	"edges":[
		{"id":"5ae2a245806da8a7","fromNode":"f1cafeacfb4afb02","fromSide":"bottom","toNode":"79f191584797c73d","toSide":"top"},
		{"id":"509fb959e5d32378","fromNode":"64c4801872a8a526","fromSide":"bottom","toNode":"79ba5cc4294d2c5d","toSide":"top"}
	]
}