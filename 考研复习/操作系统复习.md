---
title: 操作系统复习
tags:
  - 操作系统
date: 2024.03.15
---
# 1. 计算机系统概述
## 1.1 操作系统的概念
计算机系统自上而下可以划分为 4 部分：硬件，操作系统，应用程序和用户。操作系统管理各种计算机软件，为应用程序提供基础，并且充当计算机硬件与用户之间的中介。
__操作系统是指控制和管理整个计算机系统的硬件与软件资源，合理地组织，调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合，是计算机系统最基本的系统软件__。

### 操作系统的特征
1. 并发
	- 系统具有同时进行运算或操作的特性，在同一时刻可以完成两种或两种以上的工作。在宏观上，有多道程序在执行，而在每个时刻仅有一道程序执行。**CPU 与 I/O 设备 IO 与 IO 设备之间可以实现真正的并行**，如果要实现进程之间的并行需要**多流水线或多处理器**环境的支持。
2. 共享
	- 系统中的资源可供内存中多个并发执行的进程共同使用。资源共享主要方式有**互斥共享和同时访问**两种方式。
	- 互斥共享方式： 打印机，磁带机等在一段时间内只允许一个进程访问资源，这类资源称为临界资源。大多数物理设备以及软件中所用的栈，变量，表格等都属于临界资源。
	- 同时访问方式： 这类资源允许一段时间内由多个进程"同时"访问。这里的同时通常是宏观上的，而在微观上这些进程可能是交替地访问资源，也称为"分时共享"。典型的设备是磁盘设备以及一些用重入代码编写的文件。

**并发和共享是操作系统两个最基本的特征。**
两者互为存在的条件：资源共享是以程序的并发为条件的。如果系统不能对资源进行共享也会影响到并发执行。

3. 虚拟
	- 虚拟是将一个物理上的实体变为若干逻辑上的对应物。用于实现虚拟的技术称为虚拟技术。操作系统的虚拟技术可以归纳为： **时分复用技术**，如虚拟处理器；**空分复用技术**，如虚拟存储器。
4. 异步
	- 进程的执行不是一步到底而是走走停停的，以不可预知的速度推进，这就是进程的异步性。可能导致进程产生与时间有关的错误（如对全局变量的访问顺序不当）。只要运行环境相同，操作系统就需要保证多次运行进程后都能获得相同的结果。

###  操作系统的目标和功能
操作系统应具有以下几方面的功能： 处理机管理，存储器管理，设备管理和文件管理。还必须向用户提供接口。同时可以用于扩充机器以提供更方便的服务和更高的资源利用率。

操作系统也是用户与计算机硬件系统之间的接口，提供的接口主要分为两类：**命令接口和程序接口**
1. 命令接口： 主要分为联机控制方式和脱机控制方式
	1. 联机命令接口，又称为交互式命令接口，适用于分时或实时的操作系统的接口。
	2. 脱机命令接口，又称为批处理命令接口，适用于批处理系统，由一组作业控制命令组成。
2. 程序接口：由一组系统调用（也称为**广义指令**）组成。用户通过在程序中使用这些系统调用来请求操作系统的服务。

没有任何软件支持的计算机称为裸机，覆盖了软件的机器称为扩充机器或者**虚拟机**。
## 操作系统发展历程
分为手工操作阶段，批处理阶段，分时操作系统，实时操作系统，网络操作系统和分布式计算机系统，个人计算机操作系统。

1. 批处理阶段： 为了解决人机矛盾和 CPU 以及 IO 设备之间速度不匹配的矛盾。
	1. 单道批处理系统
		1. 自动性： 磁盘上的作业自动逐个运行，无须人工干预。
		2. 顺序性：作业顺序进入内存，先调入内存的先完成。
		3. 单道性：内存中仅有一道作业驻留，需要等待低速 IO 设备完成。
	2. 多道批处理系统
		1. 多道：计算机内存中同时存在多道相互独立的程序。
		2. 宏观上并行。
		3. 微观上串行。
		4. **优点是资源利用率高，系统吞吐量大。**
		5. **缺点是用户响应的时间长，没有人机交互能力。**
		6. **具有并发和并行的特点**。
2. 分时操作系统： 分时技术是将处理器的运行时间分为很短的时间片，按时间片轮流将处理器分配给各联机作业使用。
	1. 同时性：也叫多路性，允许**多个终端用户同时使用一台计算机**。
	2. 交互性：用户通过终端采用人机对话的方式直接控制程序运行，与同程序进行交互。
	3. 独立性：多个用户可以独立进行操作，互不干扰。
	4. 及时性：可以在很短时间内获得响应。
	5. **解决了人机交互问题，响应时间好**
3. 实时操作系统：
	1. 硬实时系统：某个动作必须绝对在规定时间内完成，比如飞行自动控制系统。
	2. 软实时系统：能够接受偶尔违反时间规定，比如飞机订票，银行管理系统。
	3. **计算机系统接收到外部信号后及时进行处理，并在严格时限内处理完接受事件。及时性和可靠性。交互性不如分时系统**
4. 网络操作系统：提供一种有效使用各台计算机的方法，实现各台计算机之间数据的互相传送。**网络中各种资源的共享和计算机之间的通信**
5. 分布式计算机系统：系统中的计算机都是同等地位，任何工作都可以协作完成，用于管理分布式计算机系统的操作系统称为分布式计算机系统。**分布和并行性**，与网络操作系统不同的是分布式计算机系统的若干计算机相互协同完成统一任务。
6. 个人操作系统： 目前使用最广泛的系统。Windows，linux 和 MacOS 都是个人操作系统。

## 1.3 操作系统的运行环境
### 处理器的运行模式
CPU 将运行模式划分为用户态（目态）和核心态（管态，内核态）。应用程序运行在用户态，内核程序运行在核心态。

内核一般包括四方面的内容：
1. 时钟管理： 时钟的第一功能是计时，另外还可以通过时钟中断的管理实现进程切换。
2. 中断控制
3. 原语： 定义原子操作的直接方法是关中断。
4. 系统控制的数据结构与处理：常见有进程管理，存储器管理和设备管理。

### 中断和异常
中断也叫**外中断**，是 CPU 执行指令外部的事件，通常用于输入输出，如设备发出的 IO 结束中断；**时钟中断**，表示一个时间片已到，让处理机处理计时以及启动定时运行的任务等。
异常也叫**内中断**，是来自 CPU 执行指令内部的事件，比如程序的非法操作码，地址越界，缺页以及 Trap 等的事件，**异常不可被屏蔽**，一旦出现应该立刻处理。

#### 分类
外中断分为**可屏蔽中断和不可屏蔽中断**。
异常分为**故障，中止和陷入（Trap）**。
1. 故障是由指令执行引起的异常，比如非法操作码，取页异常，除 0 以及溢出等，**有可能被处理程序处理**。
2. Trap 是一种事先安排的异常事件，用于在用户态下调用操作系统内核程序，如条件陷阱指令，系统调用等。
3. 终止是出现了使得 CPU 无法继续执行的硬件故障，如控制器出错，存储器校验错等。
4. 故障和 Trap 属于**软件中断**，终止和外部中断属于**硬件中断**。

#### 处理过程
1. 当 CPU 在执行用户程序的第 $i$ 条指令时检测到一个异常事件，或是发现一个中断请求信号，则停止当前的用户程序执行，转到相应的中断或异常处理程序的去执行。
2. 如果中断程序可以解决问题，则回到第 $i$ 或者 $i+1$ 条指令继续执行；如果是不可恢复的致命错误，则中止用户程序。

#### 系统调用
操作系统所提供的一些子功能。每个系统调用都有唯一的系统调用号。拥有设备管理，文件管理，进程控制，进程通信和内存管理等功能。
在处理系统调用时：
1. 先将系统调用号和所需的参数压入堆栈，然后执行一个 Trap 指令进入核心态，再由**硬件和内核共同保护现场，将程序计数器（PC）和程序状态字（PSW）和通用寄存器内容进行保存，其中 PC 和 PSW 由中断隐指令保存，通用寄存器由内核保存**。
2. 第二步是分析系统调用类型，转入相应的系统调用子程序。系统中有系统调用入口表，每个表项都对应一个系统调用，根据调用号可以找到系统调用处理子程序的入口地址。
3. 第三步是系统调用结束后恢复现场。返回被中断进程继续执行。

##### Tips
1. 用户程序在用户态下要使用特权指令引发的中断是陷入中断。
2. 在系统调用时需要保存 PC 和 PSW 的值，而**一般调用只需要保存 PSW 的值**。
3. PC 和 PSW 的值是由中断隐指令保存，不需要由 OS 保存。
## 1.4 操作系统结构
分层法是将操作系统分为若干层，0 层为硬件，顶层为用户接口，**每层只能调用相邻低层的功能和服务**。
优点是便于系统的调试和验证，简化实现。容易维护和扩充。问题是合理定义各层比较困难，依赖关系固定后，**灵活性**较差。**效率**较差。

模块化是将操作系统按功能划分为具有一定独立性的模块，每个模块具有某方面的管理功能，规定好各模块的接口后各模块之间可以使用接口进行通信。也叫模块-接口法。
优点是可以提高操作系统设计的正确性，可理解性和可维护性；增强了可适应性。加速了操作系统的开发过程。
缺点是接口规定很难满足对接口的实际要求；各模块的设计者齐头并进，无法找到一个可靠的决定顺序。

### 宏内核与微内核
宏内核也叫单内核或大内核，系统的主要功能模块都容纳在内核之中，各模块之间共享信息，具有**无可比拟的性能优势**。

微内核是将内核中最基本的功能保留在内核，将不需要在核心态的代码在用户态执行，降低内核的设计复杂性。
微内核的操作系统分为微内核和多个服务器，小型内核通常包含：
1. 与硬件处理紧密相关的部分，如**低级 IO**。
2. 一些较为基本的功能。
3. 客户和服务器之间的通信。
微内核通常使用**机制和策略分离**的原来来组织 OS 结构，微内核通常具有以下功能：
1. 进程管理
2. 低级存储器管理
3. 中断和陷入管理
微内核的特点：
1. 拓展性和灵活性
2. 可靠和安全性
3. 可移植性
4. 分布式计算
其最主要的问题是性能问题，因为需要频繁地在用户态和核心态之间切换。

### 外核
外核用于管理虚拟机，它为虚拟机分配资源，并检测资源的可用性。它只是用于管理硬件资源，不负责完成进程调度等。

### 操作系统引导
引导过程如下：
1. 激活 CPU，激活的 CPU 读取**ROM**中的**boot**程序，将指令寄存器设置为**BIOS**的第一条指令，开始执行**BIOS**的指令。
	- BIOS 是计算机启动时加载的第一个软件，保存着计算机最重要的基本输入输出程序，还包括开机后自检程序和系统自启动程序。
2. 硬件自检，**BIOS**程序在内存最开始的空间构建**中断向量表**，接下来的**POST**过程中会用到中断功能，然后进行**通电自检**，如果无故障屏幕会显示 CPU 内存等信息。
3. 加载带有操作系统的硬盘，通电自检后，**BIOS**开始读取**Boot Sqeuence**（通过**CMos**里保存的启动程序或者是与用户交互的方式），将控制权交给启动顺序排在第一位的存储设备，然后 CPU 将该存储设备**引导扇区**的内容加载内存。
4. 加载主引导记录（**MBR**），硬盘以特定的标识符区分引导硬盘和非引导硬盘。如果发现一个存储设备不是可引导盘，就检查下一个存储设备。无其他启动设备就会死机。**MBR**的作用是告诉 CPU 去硬盘的哪个主分区寻找操作系统。
5. 扫描硬盘分区表，加载硬盘活动分区。**MBR**包括硬盘分区表，硬盘分区表以特定的标识符区分活动分区和非活动分区。MBR 扫描硬盘分区表，进而识别含有 OS 的硬盘分区，找到硬盘活动分区后开始加载硬盘活动分区，将控制权交给活动分区。
6. 加载分区引导记录**PBR**，读取活动分区的第一个扇区，这个扇区称为分区引导记录 PBR，作用是寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）。
7. 加载启动管理器，PBR 搜索活动分区中的启动管理器，加载启动管理器。
简单地说就是
$$
开机 \rightarrow BIOS启动M B R \rightarrow MBR启动激活分区PBR \rightarrow 启动 PBR \rightarrow 启动系统
$$
### 虚拟机
第一类虚拟机是直接在硬件上取代了操作系统的位置，运行在最高特权级，裸机上。
第二类虚拟机是运行在内核上的一个用户软件。

# 2. 进程和线程
## 2.1 进程
进程是程序执行的一次执行过程，是**动态**的。

## 2.2 进程的组成
进程是独立的运行单位，也是 OS 进行资源分配和调度的基本单位。
它由： **进程控制快，程序段，数据段**组成。
最核心的是进程控制块 (PCB)。

### 2.2.1 PCB
PCB 通常包含以下内容：
1. 进程描述信息: 进程标识符 (PID)，用户标识符（UID）
2. 进程控制和管理信息：进程当前状态，优先级，代码运行入口地址，程序外存地址，进入内存时间，CPU 占用时间，信号量使用。
3. 资源分配清单：代码段指针，数据段指针，堆栈段指针，文件描述符，鼠标，键盘
4. 处理机相关信息：通用寄存器值，地址寄存器值，控制寄存器值，标志寄存器值，状态字。

### 2.2.2 程序段
程序段是能被进程调度执行到的 CPU 代码片段，程序段是只读的，可被多个进程共享。

### 2.2.3 数据段
存放运行过程中产生的各种数据。

上述三个统称为进程实体，**进程实体是静态的**。
所以说**进程是进程实体的运行过程，是资源分配和调度的基本单位**。
PCB 是进程存在的唯一标志。

## 2.3 进程的特征
进程的特征有：动态性，并发性，独立性，异步性，结构性。
另外，并发的进程会失去**封闭性**，封闭性是指进程的程序运行结果只取决于自身，而不受外界的影响。失去封闭性后，共享变量会导致其执行结果和速度有关。


## 2.4 进程的状态与转换，进程的组织
进程的五态:
1. 运行态：进程正在 CPU 上运行。
2. 就绪态：进程已经获得除 CPU 外的一切资源，系统中处于就绪态的进程被组成为就绪队列
3. 阻塞态：进程正在等待某一事件而暂停，是进程主动选择的，阻塞态的进程一般也被排成一个或多个阻塞队列。
4. 创建态：进程正被创建，尚未转到就绪态。
5. 终止态：进程正在从系统上消失。进程首先转换到终止态，然后进一步完成资源释放和回收等工作。
进程的状态由 PCB 进行记录。

活动就绪和静止就绪：活动就绪在内存中，静止就绪在外存。静止阻塞和活动阻塞同理。

活动就绪到静止就绪: `suspend` 原语。
执行到就绪: `block` 原语。
静止就绪到活动就绪: `active` 原语。
阻塞到就绪: `wakeup` 原语。

### 2.4.1 状态转换
![[Pasted image 20240503141541.png]]


### 2.4.2 进程的组织
各个进程的 PCB 以某种方式组织起来，常用的有**索引方式和链接方式**，对应起来也就是数组和链表。
连接方式：不同状态维护一个头指针结合为链表。
索引方式：不同状态维护一个索引表。

## 2.5 进程控制
进程控制就是管理进程的状态转换。
实现进程控制需要**原语**。
进程转换的操作是先设置 state，然后将其转移到其他的状态队列。由于这两个操作的不可分割性，可以使用原子操作。
原子操作原子性是由**开中断和关中断**这两个特权指令实现的。
**将进程唤醒**指的是**阻塞态到就绪态**。
### 2.5.1 进程有关的原语
1. 创建原语：申请空白 PCB，为新进程分配资源，初始化 PCB，插入 PCB 到就绪队列。
2. 撤销原语：找到对应 PCB，若进程正在运行则剥夺使用权，重新分配 CPU，终止所有子进程，释放资源归还给父进程或 OS，释放 PCB。
3. 阻塞原语：找到对应 PCB，保护进程运行现场，设置状态为阻塞态，暂停进程运行，将 PCB 插入相应事件的等待队列。
4. 唤醒原语：找到 PCB，将 PCB 从等待队列移除，设置为就绪态，将 PCB 插入就绪队列，等待调度。
5. 切换原语：将环境信息存入 PCB，PCB 移入相应队列，选择另一个进程运行，更新 PCB，根据 PCB 恢复新进程所需环境。
总体来说都是三件事：更新 PCB 信息，将 PCB 插入合适队列，分配或回收资源。

## 2.6 进程通信（IPC）
进程通信是指两个进程之间的数据交互。
需要进程通信的原因是，各进程拥有的内存地址空间是相互独立的。

### 2.6.1 共享存储
1. 基于存储区的共享： 操作系统在内存中划分出一块共享存储区，数据的形式，存放位置都由通信进程控制，是一种高级通信方式。
2. 基于数据结构的共享：规定只能用固定大小的数组等进行共享，低级共享方式。

### 2.6.2 消息传递
使用格式化的消息来共享信息。使用发送和接收原语，分为直接通信和间接通信。
间接通信是以信箱作为中间实体进行消息传递。

### 2.6.3 管道通信
管道是一种特殊的共享文件，实质就是开辟在内存中的一个大小固定的内存缓冲区。
单向管道拥有一个发送方和一个接收方。
管道和共享内存的区别是，管道类似于队列，而共享内存支持**随机存取**。
可以用两个单向管道实现双工通信。
各进程需要互斥地使用管道。

## 2.7 线程
线程是基本的 CPU 执行单元，是程序执行流的最小单位。
线程的存在可以提高系统的并发性，相同进程的线程切换几乎不耗费系统资源。

### 2.7.1 线程的实现方式
用户级线程和内核级线程。
用户线程是由应用程序通过线程库实现：
1. 所有的线程管理工作都是由应用程序负责。
2. 用户级线程中，线程切换可以在用户态下完成，无须操作系统干预。
3. 用户级线程对操作系统透明。
4. 优点是切换可以在用户空间完成，不需要切换到核心态，系统效率高开销小。
5. 缺点是一个用户级线程被阻塞后，整个进程都会被阻塞，降低了并发度，另外多个线程不可在多核处理机上并发执行。
相当于说，用户线程只是线程库模拟出来的线程。
内核级线程是操作系统实现的线程，由操作系统负责管理：
1. 操作系统管理
2. 切换在核心态下
3. 对操作系统不透明
4. 当一个线程被阻塞后依然可以继续执行，提高了并发能力。多线程可在多核上并行。

### 2.7.2 多线程模型
分为一对一模型，多对一模型， $n$ 对 $m$ 模型。
一对一：一个用户级线程映射到一个内核级线程，相当于上述的内核级线程。
多对一：多个用户级线程映射到一个内核级线程，相当于上述的用户级线程。
$n$ 对 $m$ 模型：$n$ 个用户级线程映射到 $m$ 个内核级线程 $n\geq m$，克服了多对一并发度不高的问题，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

## 2.8 线程的组织与控制
线程使用线程控制块 TCB，保存了 TID，程序计数器 PC，其他寄存器，堆栈指针，线程运行状态（用于保存和恢复），优先级等信息。


## 2.9 进程的调度
分为高级调度，中级调度，和低级调度
1. 高级调度：也叫作业调度，是将外存的作业中选择一个调入内存，并创建 PCB，**只会被调入一次调出一次**。
2. 低级调度：也叫处理机调度，是将就绪队列中选择一个分配处理机。
3. 中级调度：也叫内存调度，将挂起状态的进程调入内存。发生的频率比高级调度高。

### 2.9.1 七状态模型
加入了挂起状态。
![[Pasted image 20240503191015.png]]


### 2.9.2 进程调度的时机
进程无法在**操作系统内核程序临界区**中进行调度和切换。但是**不**代表**进程处于临界区时不能进行处理机调度**。内核资源临界区一般是用于访问某种内核数据结构，比如进程的就绪队列等。访问普通临界区可进行内核调度和切换。

### 2.9.3 进程调度的方式
分为抢占式和非抢占式。


### 2.9.4 进程的切换和过程
**狭义的进程调度**指的是从就绪队列中选择一个要运行的进程。而进程切换是指一个进程让出处理机，另一个进程占用处理机的过程。
**广义的进程调度包含了选择进程和进程切换两个步骤**。
在支持内核级线程的多线程系统里，调度器调度的对象就变成了线程。

### 2.9.5 闲逛进程
在没有其他就绪进程时运行闲逛进程。一般是零地址指令，能耗低。

### 2.9.6 调度算法的评价指标
1. CPU 利用率： CPU 忙碌的时间占总时间的比例。
2. 系统吞吐量： 单位时间内完成作业的数量。
3. 周转时间：作业被提交给系统开始，到作业完成为止的时间间隔。也就是作业完成时间 - 作业提交时间。
4. 平均周转时间： 各作业周转时间之和 / 作业数量。
5. 带权周转时间： 作业周转时间 / 作业实际运行时间。
6. 平均带权周准时间： 带权周转时间之和 / 作业数。
7. 等待时间： 进程处于等待处理机状态时间之和。
8. 响应时间： 用户从提交请求到首次产生响应的时间。

### 2.9.7 调度算法
1. 先来先服务算法（FCFS），该算法没有抢占式。
2. 短作业优先（SJF），最短的作业或进程优先得到服务，抢占版本为最短剩余时间算法（SRTN），追求最短的平均等待，平均周转，平均带权周转。拥有最短的这三个的是 SRTN，如果所有进程几乎是同时到达，同时可运行时 SJF 也拥有最短的这三者。
3. 高响应比优先（HRRN）
响应比：
$$
\frac{等待时间+要求服务时间}{要求服务时间}=1+\frac{等待时间}{要求服务时间}
$$
4. 时间片轮转调度算法（RR）
5. 优先级调度算法
6. 多级反馈队列调度算法
设置多级反馈队列，各队列优先级从高到低，时间片从小到大，新进程进入第一级队列，按照 FCFS 分配，若用完时间片还未结束，则进入下一级队列尾，如果已经是最后一级队列，则重新回到一级队列。
7. 多级队列调度算法
系统按进程类型设置多个队列，进程创建成功后插入某个队列，各个队列优先级和时间片可能不同，也可以使用不同的调度算法。可能会导致饿死。

其中**先来先服务**对长作业有利；也对 CPU 繁忙型作业有利，CPU 繁忙型作业可以看作是长作业，IO 密集型作业会频繁阻塞，不会长时间占用 CPU。

### 2.9.8 计算方法
调度算法计算周转时间等可以使用数轴：
![[Pasted image 20240505190737.png]]
在数轴上标出分界点，完成的进程画圈，用结束时间减去任务提交时间即可得周转时间。

有 IO 设备等可以并行的设备可以使用表格法：
$P_{1},P_{2},P_{3}$ 的分别的输入，运行，输出时间是 $2,3,4$:
![[Pasted image 20240505191023.png]]
从上到下和从左到右都具有先后顺序。 ***个人***感觉比甘特图更简单。

## 2.10 同步与互斥
临界资源： 需要互斥访问的资源。
访问临界资源的四个过程：
```cpp
do {
	entry section; // 进入区
	critical section; // 临界区
	exit section; // 退出区
	remainder section; // 剩余区
} while (true)
```
进入区： 检查是否可进入临界区，若能进入还应该阻止其他进程进入临街区。
临界区：访问临界资源的代码。
退出区：清除访问临界区的标志。
剩余区：其他部分。

### 2.10.1 四个原则
1. 空闲让进：临界区空闲时，可以允许进程进入临界区。
2. 忙则等待： 当有进程在临界区时，其他进程必须等待。
3. 有限等待： 请求进入的进程必须在有限时间内进入临界区，防止无限等待。
4. 让权等待（非必须）：当进程不能进入临界区时应该立刻释放处理器，防止进程忙等待。

### 2.10.2 软件实现方法
1. 单标志法
```cpp
int turn = process_id; // 当前允许进入临界区的进程号

while (turn != process_id):
critical section;
turn = other_process_id;
remainder section;
```
基本的思想就是**检查是否轮到自己使用临界资源，使用完成后，设置进程号为其他的，让对方使用临界区**。但是如果设置的进程一直没有进入临界区，就会违背**空闲让进**的原则。

2. 双标志法
```cpp
while (flag[other_prcess_id]);
flag[process_id] = true;
critical section;
flag[process_id] = false;
remainder section;
```
基本的思想就是**检测对方是否在使用临界区，如果对方没使用，就设置自己的 flag 值为 true，相当于上锁的过程；退出时解锁。**
但是如果两个进程是并发运行，当一个进程在检查完 `while` 后还没有设置标记，另外一个进程就开始运行，会导致两个进程同时进入临界区，违背了**忙则等待**的原则。
问题就是检查和上锁的动作不能一次完成。

3. 双标志后检查法
```cpp
flag[process_id] = true;
while (flag[other_prcess_id]);
critical section;
flag[process_id] = false;
remainder section;
```
先检查后上锁。**并发时可能会导致两个进程同时上锁**，就会死锁。违反了**有限等待**的原则。

4. $\mathrm{Peterson}$ 算法
```cpp
flag[process_id] = true;
turn = other_process;
while (flag[other_process] && turn == other_process);
critical section;
flag[process_id] = false;
remainder section;
```
结合了双标志和单标志，`flag` 表示进程是否想进入临界区，`turn` 表示让其他进程先使用临界区。`turn` 的值最终表示了哪个进程可以进入临界区。也就说最后给 `turn` 的值可以使用。违反了**让权 等待**的原则。

### 2.10.3 硬件实现方法
1. 中断屏蔽方法
在访问临界区时关开中断，缺点是不适用于多处理机（关中断只对执行指令的处理机有用，另外不受影响）；只适用于操作系统内核进程，不能让用户进程控制中断。
2. $\mathrm{TestAndSet}$ 指令 ($TS$ 或 $TSL$)
原子操作。功能是读出指定的标志后设置标志为真。
```cpp
while (TestAndSet(&lock));
critical section;
lock = false;
//...
```
进入上锁，完成解锁。违反了**让权等待**。
3. $\mathrm{Swap}$ 指令（$\mathrm{Exchange}$ 或 $\mathrm{XCHG}$）
原子操作。交换两个变量的值。
```cpp
bool key = true;
bool lock = false;

while (key) {
	Swap(&lock, &old);
}
// ...
lock = false;
// ...
```
跟 $TS$ 指令相同。

### 2.10.4 互斥锁 ($\mathrm{Mutex}$)
使用 `acquire()` 获得锁，`release()` 释放锁。自旋锁会导致忙等待。用于多处理机系统中，其他核不会忙等待。

### 2.10.5!!! 信号量
1. 整型信号量
表示一个资源的数目的整型变量 $S$，三种操作初始化，$\mathrm{wait(P),signal(V)}$。
$\mathrm{P}表示申请资源，\mathrm{V}表示释放资源$。
在整型信号量中资源不足也会导致忙等待。
$\mathrm{P,V}$ 操作是一种**低级进程通信原语**。

**整形信号量只能由 PV 操作来更改**.

2. 记录型信号量
在整型信号量的基础上，如果资源不足会导致进程自阻塞从而让出处理机。资源足够时又会唤醒进程。不会导致忙等待。
```cpp
typedef struct {
	int value;
	struct process* L;
} semaphore;
```
#### 2.10.5.1 信号量实现互斥
```cpp
semaphore S = 1;

process() {
	P(S);
	// ...;
	V(S);
}
```

#### 2.10.5.2 信号量实现同步
```cpp
semaphore S = 0;

process1() {
	// ...
	V(S); // 表明已完成
}

process2() {
	P(S); // 检查已完成
}
```

#### 2.10.5.3 信号量实现前驱
对前驱图的每条有向边定义一个信号量。每条有向边其实就代表了一个同步关系。
![[Pasted image 20240505201144.png]]

### 2.10.6 生产者-消费者问题
```cpp
semophore mutex = 1;
semophore empty = n;
semophore full = 0;

producer() {
	while(true) {
		produce;
		P(empty); // 消耗空闲
		P(mutex);
		add;
		V(mutex);
		V(full); // 增加产品
	}
}

consumer() {
	while (true) {
		P(full); // 消耗产品
		P(mutex);
		get;
		V(mutex);
		V(empty); // 增加空闲
		consume; 
	}
}
```
**实现互斥的操作一定要在实现同步的 $\mathrm{P}操作之后$（对后面的几种模型都一样）**。互斥锁只需要包住临界区即可。

### 2.10.7 多（类）生产者-多（类）消费者
```cpp
semaphore apple = 0;
semaphore orange = 0;
semaphore plate = 1;

dad() {
	while (true) {
		//..;
		P(plate);
		//..;
		V(apple);
	}
}

mom() {
	while (true) {
		//..;
		P(plate);
		//..;
		V(orange);
	}
}

son() {
	while (true) {
		P(orange);
		//..;
		V(plate);
	}
}

daughter() {
	while (true) {
		P(apple);
		// ..;
		V(plate);
	}
}
```
因为缓冲区大小最多为 $1$, 拥有 $\mathrm{Mutex}$ 效果，所以可以不用互斥。如果缓冲区大于一就需要设置互斥。

### 2.10.8 吸烟者问题
一个供应者进程和三个抽烟者进程，一根烟需要三种材料，三个抽烟者中每个只有其中一种材料，而供应者会提供两种材料。让三个抽烟者轮流吸烟。
```cpp
semaphore offer1 = 0, offer2 = 0, offer3 = 0, finish = 0;
int num = 0;

P1() {
	while (true) {
		num++;
		num %= 3;

		if (num == 0) V(offer1);
		else if (num == 1) V(offer2);
		else V(offer3);

		P(finish);
	}
}

P2() {
	while (true) {
		P(offer3);
	// ..;
		V(finish);
	}
}

P3() {
	while (true) {
		P(offer2);
	// ..;
		V(finish);
	}
}

P4() {
	while (true) {
		P(offer1);
	// ..;
		V(finish);
	}
}
```

### 2.10.9 读写者问题
不能同时写但是可以同时读。
```cpp
semaphore rw = 1, mutex = 1;
int cnt = 0;

writer() {
	while (true) {
		P(rw);
		writing;
		V(rw);
	}
}

reader() {
	while (true) {
		P(mutex);
		if (cnt == 0) P(rw);
		cnt++;
		V(mutex);
		reading;
		P(mutex);
		cnt--;
		if (cnt == 0) V(rw);
		V(mutex);
	} 
}
```
由第一个读者负责加锁，最后一个负责解锁。刚来的开灯，最后走的关灯。
会导致写者饿死的问题。

相同优先级的写法：
```cpp
semaphore rw = 1, mutex = 1, w = 1; // w 保证写者优先
int cnt = 0;

writer() {
	while (true) {
		P(w);
		P(rw);
		writing;
		V(rw);
		V(w);
	}
}

reader() {
	while (true) {
		P(w);
		P(mutex);
		if (cnt == 0) P(rw);
		cnt++;
		V(mutex);
		V(w);
		reading;
		P(mutex);
		cnt--;
		if (cnt == 0) V(rw);
		V(mutex);
	} 
}
```

### 2.10.10 哲学家问题
五位哲学家环坐，一共只有五只筷子，每位哲学家只能拿左手和右手边的筷子。
```cpp
semaphore cs[] = {1, 1, 1, 1, 1};
semaphore mutex = 1;

Pi() {
	do {
		P(mutex);
		P(cs[i]);
		P(cs[(i+1)%5]);
		V(mutex);
		// ..;
		V(cs[i]);
		V(cs[(i+1)%5]);
		// ..;
	} while (1);
}
```
$\mathrm{V}$ 操作可以不用互斥，因为不会导致阻塞。

### 2.10.11 信号量问题的基本步骤
1. 分析各进程间的制约关系，从而得出同步与互斥关系  
2. 根据 1中的分析，设置信号量  
3. 编写伪代码，实施 P,V 操作
同步：多个进程在执行次序上的协调，相互等待消息  
互斥：对临界资源的使用
要注意的是，**虽然 P,V 操作在每一个进程中都是成对出现的，但不一定是针对一个信号量。互斥信号量的 P,V 操作总是出现在一个进程中的临界区的前后，而同步信号量的 P,V 操作总是出现在具有同步关系的两个进程中，需要等待消息的一方执行 P 操作，发出消息的一方执行 V 操作。**

### 2.10.12 管程
管程是自带互斥功能的类。每次仅允许一个进程进入管程，从而实现进程**互斥和同步**。
基本的操作是 `take_away()` 申请资源，`give_back()` 归还资源。
特点：
1. 需要在管程中定义共享数据，例如缓冲区。
2. 需要在管程中定义访问共享数据的函数。
3. 只有需要的入口才可以访问共享数据。
4. 管程中每次只能开放一个入口，让一个**进程或线程**进入，互斥特性是***编译器***实现的，而同步特性是**编程语言**支持的。
5. 可在管程中定义条件变量以及等待唤醒以解决同步问题，可以让一个线程或进程在条件变量上等待。此时进程应该先释放管程使用权，让出入口；可以通过唤醒操作将等待在管程上的进程或者线程唤醒。
管程的条件变量是引发进程阻塞的原因，与信号量不同的是，信号量有值，而条件变量仅仅维护阻塞队列。
### 2.11 死锁
死锁发生的必要条件：
1. 互斥条件： 只有对互斥资源的争抢才会导致死锁。
2. 不可剥夺条件： 进程获得的资源在未使用完前，不能由其他进程夺走。
3. 请求和保持条件： 进程已经保持了至少一个资源，提出新的资源请求请求其他进程所持有的资源，此时请求进程被阻塞，但是又不放弃自己的资源。
4. 循环等待条件： 存在进程资源的循环等待链。
对不可剥夺的资源的不合理分配就可能会导致死锁。

静态资源分配法，也叫资源的顺序分配策略（不是资源的线性分配策略）破坏的是**请求和保持条件**。

### 2.11.1 死锁的预防
破坏互斥条件：
将互斥资源改造程允许共享使用，比如 $\mathrm{SPOOLing}$ 技术。

破坏不可剥夺条件：
1. 当进程申请的资源无法满足，立刻释放自己的所有资源。
2. 当进程申请的资源无法满足时，由操作系统协助，将想要的资源强行剥夺。

破坏请求和保持等待：
采用静态分配办法，在一次申请全部资源。

破坏循环等待条件：
采用顺序资源分配法，给进程编号，规定按编号递增的顺序请求资源。

### 2.11.2 死锁的避免
以一个序列分配资源如果能让进程资源全部满足，则是安全序列。
银行家算法： $\mathrm{DFS}$ 寻找安全序列。
当系统处于安全状态时，系统中一定无死锁进程，也一定不会死锁。
当系统处于不安全状态时，系统不一定会死锁。

答题方法：
![[831ba7f01093d0427c278423ff46bb98_720.jpg]]



### 2.11.3 死锁的检测和解除
死锁检测：用数据结构保存资源分配和请求信息，再用算法检测是否已进入死锁状态。
![[Pasted image 20240506132545.png]]
如果可以消去图中所有的边，说明不会发生死锁。
在资源分配图中，找出不阻塞又不是孤立点的进程，消除它所有的请求边和分配点，让它成为孤立点。如果找到一种方法可以消除所有边，则图**可完全简化**，不会死锁。

**死锁定理**：如果资源分配图中没有环路则系统中没有死锁，如果图中有环路可能会死锁，如果每个资源类只包含一个资源实例，则环路是存在死锁的充要条件。

死锁解除: 资源剥夺法，终止进程法，进程回退。

# 3. 内存管理
基本的要求是**内存空间的分配和回收，地址转换，内存空间的扩充，内存共享，内存保护**。

三种装入方式：
1. 绝对装入： 编译时产生绝对地址。
2. 可重定位装入： 装入时将逻辑地址转换为物理地址。
3. 动态运行时装入： 运行时将逻辑地址转换为物理地址，需要设置重定位寄存器。共用重定位寄存器, 仅在进程切换时进行保护和恢复. 另外也需要**地址变换机构**.

重定位分为静态重定位: 只在程序装入时进行一次地址修改, 而动态重定位可以在程序**运行时**移动程序的位置.

操作系统通过内存管理部件（$\mathrm{MMU}$）来实现逻辑地址转换为物理地址。

内存保护的方法：
1. 设置上下限寄存器。
2. 设置重定位寄存器（基地址寄存器）和界地址寄存器（限长寄存器）来进行检查。

## 3.1 覆盖和交换
覆盖技术： 按照逻辑让不可能被同时访问的程序段共享覆盖区，覆盖区是程序员自己声明的。
交换技术： 内存空间紧张时，将内存中某些进程暂时换出外存，将外存中已具备运行条件的进程换入内存。暂时换出外存的进程是挂起态，分为就绪挂起和阻塞挂起态。

## 3.2 连续分配的管理方式
系统为用户进程分配一个连续的内存空间。

单一连续分配： 将系统分为系统区和用户区，系统区位于低地址部分，**内存中只能有一道用户程序**。无外部碎片。
固定分区分配： 将用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业。操作系统需要建立一个分区说明表，来说明分区是否被分配。无外部碎片。
动态分区分配： 不预先划分内存分区，而是根据装入内存时进程大小动态建立分区。可以使用**空闲分区表和空闲分区链**来维护。有外部碎片。

## 3.3 分配算法
1. 首次适应算法： 空闲分区按地址递增的次序排列，每次分配按顺序查找空闲分区表，找到第一个满足大小的分区。
2. 最佳适应算法： 空闲分区按容量递增的次数排列。
3. 最坏适应算法：空闲分区按容量递减次数排列。
4. 邻近适应算法： 按地址递增排列，每次分配时从上次查找结束的位置开始查找空闲分区表。
5. 伙伴系统： 规定分区大小是 $2^k$, 当需要为进程分配大小为 $n$ 的分区时 $(2^{i-1}\leq n\leq 2^i)$ ，在大小为 $2^i$ 的空闲分区链查找，找到则分配，否则表示分区已经耗尽，需要在大小为 $2^{i+1}$ 的空闲分区链继续查找，若存在则将其分为两个分区，这两个就称为**一对伙伴**，其中一个用于分配，另外一个就加入大小为 $2^i$ 的空闲分区链，回收时也可能需要对伙伴分区进行合并。
## 3.4 基本分页存储
将内存空间分为一个个大小相等的分区 ,称为页框。
将地址的逻辑地址分为和页框大小的页或页面。
操作系统以页框为基本单位分配空间。
各个页面不必连续存放。

### 3.4.1 页表
页表由页表项组成，页表项由页号和块号组成。
![[Pasted image 20240506172107.png]]
也就是页号-页框号，表示进程的每一页在哪个页框里面。
页号可以是隐含的，不占用存储空间。所以可以不必存储页号的信息。
$$
页号 = \frac{逻辑地址}{页面大小}
$$
$$
偏移量 = 逻辑地址\mod{页面大小}
$$

### 3.4.2 基本地址变换机构
在系统中设置页表寄存器 ($\mathrm{PTR}$), 存放**页表在内存中的起始地址**和**页表长度**。
如果页表的逻辑地址是 $2^k$, 那么可以把逻辑地址看作是二进制的页号和页内偏移量的拼接，后面 $k$ 位代表偏移量，前面单独取出来是页号。
1. 根据逻辑地址计算出页号和偏移量。
2. 检查页号是否越界。
3. 查询页表找到页表对应的页表项，确定页框号。
4. 用页框号和偏移量算出物理地址。
**查找页表**的工作也是由硬件完成, 并不需要操作系统的干预.
根据一个地址便可以得到地址, 因为只需要一维的地址即可.
物理地址也是**物理块号**, 块内偏移量的构成, 也可以用一个一维地址来表示.

转物理地址的时候, 后面偏移量可以直接替换, 前面虚拟页面替换成物理页框号即可.

### 3.4.3 具有快表的地址变换机构
快表又叫联想寄存器 $\mathrm{TLB}$, 它不是内存，不是寄存器，而是一种高速缓存，用来存放最近访问的页表项的副本，可以加入地址变换的速度。快表中存储的是**页表项**。
加入快表后会先查询快表。
有的系统支持快慢同时查询，差距就是快表不命中的时候不包含访问快表的时间。但是命中的话还是需要查询快表的时间。

### 3.4.4 两级页表
多级页表是为了解决页表项（在内存中）占用空间过大的问题。可以允许页表项离散存储。
![[Pasted image 20240506183402.png]]
把页表也认为是页装进页框里面。再用顶级页表寻找二级页表，进而找到内存。
多级页表省内存的原因是，二级页表可以按需创建。页表是数组的索引，假如只用到了 $[2]$ 和 $[98]$, 剩下的位置也需要全部留出来，哪怕没有使用它，而有了二级页表之后二级页表只需要按需创建即可。二级页表甚至可以换到外存去存储。

## 3.5 基本分段存储
地址空间按照程序自身逻辑关系划分为若干段，每个段有一个段名，每段从 $0$ 开始编址。
分段系统的逻辑地址结构由段号和段内地址组成，段号位数决定了每个进程最多分为几个段，而段内地址位数决定了每个段的最大长度是多少。
段表记录了逻辑段和物理段的关系。

![[Pasted image 20240509194631.png]]

**段表寄存器**存放了**段表始地址**和**段表长度**两个信息。
所以地址转换的流程就是：
1. 根据逻辑地址得到段号，段内地址
2. 判断段号是否越界，如果则产生越界中断。
3. 查询段表找到对应的段表项。
4. 检查段内地址是否超过短长，如果则产生越界中断，否则继续执行。
5. 物理地址，段基地址+段内地址。

不能被修改的代码称为纯代码或者是**可重入代码**，可以共享访问。
分页管理不会产生外部碎片，只有少量内部碎片，而分段管理会有外部碎片，且更容易实现信息共享与保护。但是不会产生**内部碎片**.

段式管理可以设置共享段表, 来让**多个进程**共享同一段代码或者数据.
## 3.6 段页管理
逻辑地址由段号，页号，页内偏移量组成。
段页式管理中，段表项又**段号，页表长度，页表的页框号（页表起始地址）组成**，每个段表项长度相等，段号隐含。
![[Pasted image 20240509200439.png]]
一个进程只会一个段表，一个段表会对应多个页表。

地址转换过程：
1. 根据逻辑地址得到段号，页号，偏移量。
2. 检查段号是否越界。
3. 查询段表找到页表项。
4. 检查页号是否越界。
5. 根据页表存放块号，页号查询页表，找到页表项。
6. 根据内存块号，业内偏移量得到最终物理地址。


## 3.7 虚拟内存
将会用到的部分才调用内存，不用的换出外存。
拥有三个特征：
1. 多次性： 无需一次全部调入内存，可以允许多次调入。
2. 对换性： 在作业运行时无需一直常驻内存。
3. 虚拟性： 逻辑上扩充内存容量。
最主要的区别就是： 需要访问的信息不在内存时，将信息调入内存，内存不足时再换出外存。
实现虚拟内存基于离散分配的内存管理方式。

### 3.7.1 请求分页管理方式
页表新增**状态位（是否在内存中），访问字段（可记录最近被访问几次，或着记录上次访问的时间），修改位（页面调入内存后是否被修改果），外存地址**。

为了实现请求分页需要实现缺页中断机构：
在请求分页系统中，当要访问的页面不在内存中时，便产生一个缺页中断，然后由操作系统的**缺页中断处理程序**处理中断。
此时缺页的进程被**阻塞**，放入阻塞队列，掉页完成后再将其唤醒，放回就绪队列。

如果内存中有空闲块，则分配一个，装入页面到该块，修改页表项，如果没有则由页面置换算法选择一个页面淘汰，如果被修改过还需要写回外存。

地址变换机构：
当访问信息不在内存时，需要由操作系统将所需信息调入内存，若内存空间不够还需要将用不到的信息换出外存。

**虚拟存储器的最大容量是由地址结构决定，和物理能存的容量无关。**
### 3.7.2 置换算法
目的是追求最低缺页率。
1. 最佳置换算法
选择淘汰永不使用或者最长时间内不被使用访问的页面。
2. 先进先出置换算法
每次淘汰最早进入内存的页面。
只有它有 $\mathrm{Belady}$ 异常。
3. 最近最久未使用算法 ($\mathrm{LRU}$)
淘汰最近最久未使用的页面，用访问字段记录该页面被上次访问以来所经理的时间，选择最大的页面。
4. 时钟置换算法 ($\mathrm{CLOCK}$)
也叫最近未使用算法 $\mathrm{NRU}$, 为每个页面设置一个访问位，再将页面都链接成循环队列。当某页面被访问时设置访问位置为 $\mathrm{1}$, 当需要淘汰时，检查访问位，如果是 $0$ 就换出，如果是 $1$, 就设置为 $0$。
若第一次扫描中所有页面都是 $1$, 那么将这些页面的访问位依次设置为 $0$ 后进行第二轮扫描，因此一次 $\mathrm{C\mathcal{L}OCK}$ 算法最多会经过两轮扫描。
5. 改进型的 $\mathrm{CLOCK}$ 算法
再添加一个修改位，优先淘汰没有被修改过的页面，因为没有修改过的页面不用写回外存。用 $(访问，修改)$。
1. 扫描 $(0,0)$ 用于替换，不修改任何标志位。
2. 扫描 $(0,1)$ 用于替换，将访问位设置为 $0$。
3. 扫描 $(0,0)$ 用于替换，不修改任何标志位。
4. 扫描 $(0,1)$ 用于替换。
最多进行四轮扫描。

### 3.7.3 页面分配策略
工作集：一段时间内进程要访问的页面的集合。只包含当前 $k$ 次的集合，其中 $k$ 是工作集大小。
驻留集： 请求分页存储管理中给进程分配的物理块的集合。驻留集大小一般大于进程的总大小。
固定分配: 驻留集大小不变。
随机分配：大小可变。
局部置换：发生缺页时只能选自己的物理块进行置换。
全局置换：可以将操作系统保留的和其他进程持有的物理块置换到外存。
可以组合： 固定分配局部置换，可变分配全局置换（只要缺页就分配新的物理块），可变分配局部置换（根据缺页率动态增加和减少物理块数量）。

如果系统有足够的对换区空间，页面调入调出都是在内存和对换区进行，如果不足，则不会被修改的从文件区调入，会被修改的和对换区调入。

抖动现象： 进程频繁访问的页面数目高于可用的物理快数（分配给进程的物理块数目不足）。
工作集 ： 某段时间间隔里，进程实际访问页面的集合。

### 3.7.4 内存映射文件
便于访问文件，使用 `mmap` 系统调用映射文件到内存，就可以按内存的方式来访问文件（支持随机存取）。多个进程也可以映射同一个文件以实现**共享**。
同时也可以通过修改内存中的数据来实现文件的写操作。

# 4. 文件管理
文件分为有结构文件和无结构文件，无结构文件又叫流式文件，有结构文件有一组相似的记录组成，又叫记录式文件，每条记录由若干数据项组成，一般来说每条记录有一个数据项作为关键字。
根据各条记录的长度是否相等，又可以分为**定长记录**和**可变长记录**。
优结构文件分为三类： 顺序文件，索引文件，索引顺序文件。
顺序文件：文件中的记录逻辑上连续存储，物理上可顺序可链式。顺序文件又可以分为串结构和顺序结构，串结构记录之间的顺序和关键字无关，顺序结构记录之间的顺序按关键字顺序排列。
索引文件：建立一张索引表以加快文件的检索速度，每条记录对应一个索引项 $(索引号,长度,指针)$。
索引顺序文件：一组记录对应一个索引表项，对关键字进行分组，再根据每组的第一个关键字再建立索引表。

## 4.1 文件目录
使用 $\mathrm{FCB}$ 文件控制块来管理文件，一个就是一个文件目录项，里面包含了文件的基本信息，文件名，物理地址，逻辑结构物理结构等，存取控制信息，使用信息等。最重要最基本的还是文件名和文件存放的物理地址。

单级目录结构：只有一个主目录结构。
两极目录结构：分为主文件目录和用户文件目录。
多级目录结构：又叫树形目录结构，文件路径名是字符串，从根目录出发的路径是绝对路径。

## 4.2 文件的物理结构
磁盘中的存储单元被划分为一个一个块，读写是以块为单位的。
文件的逻辑地址也可以表示为 `(逻辑块号，块内地址)` 的形式。

### 4.2.1 文件分配方式
1. 连续分配
每个文件在磁盘上占有一组连续的块。
可以直接根据逻辑块号算出对应的物理块号，因此支持顺序访问和随机访问。
连续分配的文件在顺序读写时速度最快。
2. 链接分配
在目录中记录文件的起始块号和结束块号，并在文件的每一个磁盘块中保存指向下一个盘块的指针。
用户给出要访问的逻辑块号 $i$, 操作系统找到该文件对应的目录项 $FCB$。然后从目录项中找到起始块号，将 $0$ 号逻辑块读入内存，由此知道 $1$ 号逻辑块的存储位置...，由此，读入 $i$ 号逻辑块，共需要 $i+1$ 次磁盘 $IO$，因为从 $0$ 开始计算的。
也可以使用显式链接，在目录中只记录起始块号，然后把用于链接文件各物理块的指针显式地存放在一张表中。即文件分配表 $FAT$。
每一项是 `(物理块号，下一块)`。
![[Pasted image 20240710153723.png]]
一个磁盘仅需要设置一张 $FAT$, 在启动时读入内存后常驻。
注意逻辑快号转换为物理块号的操作并不需要读取磁盘。有分配表可以随机访问 (对磁盘而言，意思是只需要访问一次磁盘)，并不能随机访问 $FAT$。
3. 索引分配
为每个文件建立一张索引表，索引表记录了文件的各个逻辑块对应的物理块。索引表存放的磁盘块称为索引块，文件数据存放的磁盘块称为数据块。
索引表的逻辑块号可以是隐含的。支持随机访问。

**访问速度最快的是哈希文件.**

索引表的分配：
1. 链接方案
将多个索引块链接起来存放。需要顺序地去查找索引表。
2. 多级索引
建立多级索引表。如果采用 $K$ 层索引结构，且**顶级索引表没有调入内存**则需要 $K+1$ 次磁盘 $IO$。
3. 混合索引
一个文件的顶级索引表中包含一些直接地址索引 (指向数据块)，又包含一级索引（指向单层索引表），又包含两级间接索引（指向两层索引表）。

### 4.2.2 文件存储空间管理
1. 空闲表法
给所有连续的空闲盘块组成一张空闲表，`(第一个空闲盘块号，空闲盘块数)`。分配方法可以采用首次适应，最佳适应，最坏适应等方法。回收时需要注意表项的合并问题。
2. 空闲链表法
空闲盘块链：以盘块为单位组成一条空闲链。
空闲盘区连：以盘区（若干连续盘块）为单位组成一条空闲链。
3. 位示图法
用连续的字表示位示图，字中的每一位对应一个盘块，可以用 `字号，位号` 对应一个盘块号。
4. 成组链接法
在目录区中设计一个超级块，先记录一个下一组的空闲盘块数，接下来是对应数量的空闲盘块号。

### 4.3 文件共享
文件共享只有一份文件，其中一个用户修改了文件数据，对其他用户也可见。
1. 基于索引结点的共享方式（硬链接）
在索引结点中设置一个链接记数 `count`, 每有一个共享就加一，只有为 $0$ 的时候才能真正删除。
2. 基于符号链接的共享方式
链接类型的文件记录了文件的存放路径，类似于快捷方式。

软连接不增加引用计数，而硬链接增加引用记数，且硬链接和被链接的文件引用计数相同。

## 4.4 文件保护
1. 口令保护
为文件设置口令，提供口令才可以访问。
2. 加密保护
使用密钥对文件进行加密，有密码才可以正确解密。
3. 访问控制
为每个文件的 $FCB$ 增加一个访问控制表 $ACL$，记录了各用户可以对文件执行哪些操作。

## 4.5 文件系统的全局结构
物理格式化（低级格式化）：划分扇区，检测坏扇区，用备用扇区替换坏扇区？

## 4.6 虚拟文件系统
虚拟文件系统是系统调用接口，屏蔽底层具体文件系统的实现差异。
每打开一个文件，会新建一个 $vnode$, 用统一的数据结构表示文件，无论该文件存储在哪个文件系统。
$vnode$ 只在主存中，$inode$ 会同时存在主存和外存中。

# 5. $IO$ 管理
### 5.1 $IO$ 设备的概念和分类
按信息交换分类：块设备（可随机，可寻址）和字符设备（传输慢，不可寻址，中断驱动）。
按特性分类：人机交互类，存储，网络通信
按传输速率：低速，中速，高速。
	
### 5.2 $IO$ 控制器
用于实现 $CPU$ 到设备的控制，$CPU$ 控制 $IO$ 控制器，再由 $IO$ 控制器来控制设备的机械部件。
其中会设置控制寄存器来存放命令和参数，状态寄存器记录 $IO$ 设备的当前状态，数据寄存器用于暂存数据。
功能：
1. 接受和识别 $CPU$ 发出的指令
2. 向 $CPU$ 报告设备状态
3. 数据交换
4. 地址识别
可以让寄存器占用内存的一部分，叫内存映像 $IO$, 也可以使用寄存器特有的地址，叫寄存器独立编址。

## 5.3 $IO$ 控制方式
1. 程序直接控制方式
基本思想是轮询。
完成一次读写的流程：
1. $CPU$ 向控制器发出读指令。于是设备启动，并将状态寄存器设置为 $1$（未就绪）。
2. 不断轮询检查控制器的状态。
3. 若设备已就绪，将数据寄存器中的内存读入 $CPU$ 的寄存器。
4. 将寄存器的数据写入到存储器中的内存单元。
2. 中断驱动方式
使用中断机制，当等待 $IO$ 的进程阻塞，先切换到别的进程执行，完成后控制器发送中断信息，然后去执行中断处理程序处理中断，过程中从控制器中读取一个字的数据送到寄存器再写入主存。
 缺点是每次中断只能处理一个字，消耗时间。
 3. $DMA$ 方式
直接存储器存储，主要用于块设备的控制。
数据传送的单位是块，不再是一个字的传送。
数据的流向是从设备直接放入内存，或者从内存直接到设备，不再需要 $CPU$。
仅在传送一个或多个数据块的开始和结束时才需要 $CPU$ 干预。
$DMA$ 控制器是一种 $IO$ 控制器，其中包含一些寄存器来处理。
4. 通道控制方式
通道相当于一种微型的 $CPU$, 可以识别并执行一系列的通道指令。
$CPU$ 将指令分配给通道让通道去执行。
每次读写一组数据块，不经过 $CPU$, 直接从 $IO$ 设备到内存。
一个通道可以控制多个控制器，一个控制器可以控制多个设备。
![[Pasted image 20240710174500.png]]

## 5.4 $IO$ 应用程序接口和驱动程序接口
为不同类型的 $IO$ 设备设置不同的输入输出应用程序接口。

可以分为**块设备接口，流设备接口和网络接口**.

### 5.5 $IO$ 核心子系统
核心字系统是设备独立性软件，设备驱动程序，中断处理程序。

设备独立性软件是与设备无关的软件，$IO$ 软件独立于具体使用的物理设备，这提高了 $IO$ 系统的可适用性和可拓展性，设备独立性软件包括了**设备命名，设备分配，数据缓冲，数据高速缓冲**.

设备驱动程序是进程和设备控制器之间的通信程序，功能是**将上层发来的抽象 IO 指令转换为具体的命令和参数, 并把它装入到设备控制器中的命令和参数寄存器**.

中断控制器位于 $IO$ 系统的底层，直接与硬件进行交互，当有 $IO$ 设备发来中断请求信号时，在中断硬件做了初步处理后，便转向中断处理程序.

### 5.5.1 假脱机技术
假脱机技术用软件模拟脱机技术。
当多个进程提出输出打印的请求时：
在磁盘输出井中为进程申请一个空闲缓冲区（在磁盘上），将打印的数据复制到其中。
为用户进程申请一张空白的打印申请表，并将用户的打印请求填入表中，再将该表挂在假脱机文件队列上。打印机空闲时从队列取出一张打印请求表，并根据表中要求将数据从输出井传送到输出缓冲区，再输出到打印机进行打印。

>组成部分\

1. 输入井和输出井，在磁盘中开辟的两个大存储空间，分别模拟脱机输入和脱机输出时的磁盘设备，用于暂存 IO 设备输入和输出的数据。
2. 输入缓冲区和输出缓冲区。目的是缓和 $CPU$ 和磁盘之间速度不匹配矛盾，分别用于暂存由输入设备送来的数据，然后传送到输入井中。
3. 输入进程和输出进程。模拟脱机 IO 时的外围控制机，输入进程模拟脱机输入时的外围控制及，将用户要求的数据从输入机通过输入缓冲区再送到输入井，当 $CPU$ 需要输入数据时，直接从输入井读入内存；输出进程模拟脱机输出时的外围控制机，把用户要求输出的数据先从内存送到输出井，等待输出设备空闲时，在将输出井中的数据经过输出缓冲区送到输出设备上。

>工作原理

核心思想是以联机的方式得到脱机的结果。低速设备经通道和外设在主机内存中形成缓冲区，在高级设备形成输出井和输入井，传到缓冲区，再传到低俗设备，利用其中一道或者两道模拟脱机输入输出中的外围控制机的功能，以达到假脱机的目的，可以把独占的设备转换为共享的虚拟设备。

### 5.6 设备的分配和回收
静态分配： 进程运行前分配所有资源，结束后归还
动态分配：动态申请资源。

设备控制表 $DCT$
系统为每个设备配置一张 $DCT$, 用于记录设备情况。
设备类型，标识符，状态，指向控制器表的指针，重复执行次数或者时间，设备队列的队首指针。

控制器控制表 $COCT$
为每个设备控制器配置一张 $COCT$，对控制器进行操作和管理。

$通道控制表CHCT$
每个通道配置一张 $CHCT$，对通道进行操作和管理。

系统设备表 $SDT$
记录了系统中全部设备的情况，每个设备对应一个表目。

>逻辑设备表

逻辑设备表中包含**逻辑设备名，物理设备名，设备驱动的入口地址**.

### 5.7 缓冲区管理
单缓冲：在主存中分配一个缓冲区，大小和块相同。
缓存区不空时只能取数据不能存数据，空时可以存数据，但是必须先存满才可以传出。

双缓冲：分配两个缓冲区。

循环缓冲区：将多个大小相等的缓冲区连接成一个循环队列。$in$ 指向指向下一个可以写入数据的缓冲区，$out$ 指向下一个可以取出数据的缓冲区。

缓冲池由系统中共用的缓冲区组成，按使用情况可以分为：空缓冲队列，装满输入数据的缓冲队列（输入队列），装满输出数据的缓冲队列（输出队列）。

### 5.8 磁盘的结构
柱面（磁道），盘面，扇区。
存储时按照扇区，盘面，柱面的顺序填充。

低级格式化（物理格式化）：空白磁盘分扇区。
高级格式化（逻辑格式化）：创建文件系统。

一般磁盘是从外侧 (0) 到内侧开始编号。

### 5.9 磁盘调度算法
寻道时间： $T_{s}$, 将磁头移动到指定磁道需要的事件，启动磁头臂需要时间 $s$, 移动磁头跨越一个磁道耗时为 $m$, 总共需要跨越 $n$ 条磁道，总时间就是 $T_{s}=s + m \times n$。
延迟时间：通过旋转磁盘让磁头定位到目标扇区需要的事件，设转速为 $r$, 则延迟事件是 $T_{R}=\left( \frac{1}{2} \right)* \left( \frac{1}{r} \right)$ (平均只走一半) 。
传输时间 $T_{t}$: 假设转速为 $r$, 读写 $b$ 个字节，每个磁道上字节数是 $N$，占用 $\frac{b}{N}$ 个磁道。
则传输时间 $T_{t}=\left( \frac{1}{r} \right)*\left( \frac{b}{N} \right)=\frac{b}{rN}$。

$SCAN$ 算法：到最右边的磁道再反向寻找。
$LOOK$ 算法：处理完最右边的请求就反向寻找。
$C-SCAN$： 到最右边的磁道后快速返还最左边的位置，再开始处理。
$C-LOOK$ 算法：返回到第一个请求的位置。

# 6. 计算专题
>页式存储的计算

已知系统为 $32$ 位实地址，采用 $48$ 位虚拟地址，页面大小 $4KB$, 页表项 $8B$, 每段最大为 $4GB$。
1. 假设系统采用纯页式存储，则需要采用多少级页表，页内偏移多少位？
由于页面大小 $4KB=2^{12}$, 因此需要 $12$ 位的页内偏移，那么还有 $36$ 位可供页表使用，每一个页面可以容纳的页表项是 $\frac{4KB}{8B}=2^9$, 表示最多可以容纳 $2^9$ 个页号，而虚页号一共有 $36$ 位，所以需要 $\frac{36}{9}=4$ 级页表。
2. 假设采用一级页表，$TLB$ 命中率是 $98\%$, $TLB$ 时间是 $10ns$, 访问内存是 $100ns$, 假设 $TLB$ 访问失败后访问，求平均页面访问时间。
$$
98\% \times (10+100)ns + 2\% \times (10 + 100 + 100)ns = 112ns
$$
3. 如果是二级页表，那么是多少？
$$
0.98 \times (10 + 100) + 0.02 \times (10 + 100 + 100 + 100) = 114ns
$$
4. 上题中如果要满足访问时间 $\leq 120ns$, 至少需要多少的命中率？
即
$$
p \times (10 + 100)ns + (1-p) \times (10 + 100 + 100 + 100)ns = 120 ns \to p = 95\%
$$

# 简答题

## 批处理系统及其优点

批处理系统是用户准备好要执行的程序, 数据和控制程序执行的说明书, 由操作员输入到计算机系统中等待处理, 操作系统选择作业并按照作业说明书要求自动控制作业执行.

优点:

多道作业可以并行工作, 减少 CPU 的时间开销
作业调度可以合理选择转入主存中的作业, 充分利用计算机资源
作业执行过程中不访问低速设备而直接访问高速的磁盘设备, 缩短执行时间
作业成批输入可以减少 IO 次数

## 多道程序设计

允许多个程序同时进入同一个计算机系统的主存中并启动进行运行计算的方法, 计算机内存里可以同时驻留多道独立程序.
他们都处于开始和结束之间, 从宏观看是并行的, 多道程序都处于运行中而没有结束.
从微观上看是串行的, 各程序轮流使用 CPU, 交替执行, 引入多道程序设计的根本目的是提高 CPU 的利用率, 充分发挥计算机的并行性.

## 分时技术

分时技术是把运行时间分为很短的时间片,，按时间片轮流地把 CPU 分配给各个联机作业使用, 如果某个作业分配给他的时间片用完之前未完成则中断, 再调入就绪队列中等待分配下一个时间片.

## 系统调用和库函数的区别

库函数是应用程序的一部分, 可以运行在用户空间中, 而系统调用是操作系统提供的, 是 OS 提供给用户程序的接口来使用操作系统提供的服务. 通过陷入指令进入内核态, 运行在内核空间中, 许多库函数都会使用系统调用来实现功能, 没有使用系统调用的库函数效率通常比使用系统调用的高, 因为涉及内核态和用户态的转换.

## 进程和程序的区别

进程是动态的而程序是静态的.
进程是短暂的, 而程序是永久的
进程的组成包括数据段, 程序段和 PCB
一个程序可以产生多个进程, 一个进程也可以实现多个程序
进程具有并发性而程序没有.

## 进程的定义和引入的原因

进程是具有独立功能的程序在有关数据的一个动态的程序执行的过程, 它是资源分配的基本单位.

原因是为了更好的控制和描述程序的并发执行, 实现操作系统流的并发和共享, 提高系统的资源利用率和吞吐量.

## 引入 PCB 的原因和 PCB 的组成, 为什么说 PCB 是进程存在的唯一标志, PCB 的作用是什么?

引入 PCB 是为了管理和控制进程的并发执行, 并协助进程完成状态的转换.

组成:

进程的描述信息: 进程标识符, 用户标识符
进程的管理和控制信息: 进程优先级, 当前状态, 进入内存时间, 处理机占用时间.
资源分配清单: 程序段指针, 数据段指针, 堆栈段指针.
处理机相关的信息: 通用寄存器值, 程序状态值

为什么是存在的唯一标志: 在进程的生命周期中, 操作系统总是通过 PCB 来感知进程的存在, 通过 PCB 对其进行控制. 

作用: 在多道程序中支持多进程的并发执行, 对进程进行控制.

## 引入线程原因

减少程序并发执行时造成的时空开销, 让操作系统有更好的并发度, 提高 OS 的效率.

## 创建进程的原因和过程

**4 个**.

原因: 用户登录, 作业调度, 系统提供服务, 用户程序的应用请求.

**申请 PCB, 分配资源, 初始化 PCB, 插入队列**

过程:

1. 为进程分配一个唯一的标识符, 并申请 PCB
2. 为进程分配资源, 为新进程的程序, 数据, 以及栈等分配必要的空间, 若失败则阻塞.
3. 初始化 PCB, 主要包括初始化进程信息, 处理机状态控制和设置优先级等.
4. 如果就绪队列还有空, 则将 PCB 插入就绪队列等待调度.

## 进程切换的过程

1. 保存处理机的上下文, 包括程序计数器和其他寄存器
2. 更新 PCB 信息, 将上述信息保存在 PCB 中
3. 把进程 PCB 移到相应的队列中, 如就绪队列或某事件的阻塞队列
4. 选择另外一个进程执行, 更新 PCB
5. 更新内存管理的数据结构
6. 恢复处理机上下文

## 进程阻塞的原因和过程

原因: 

请求系统资源失败, 等待操作完成, 新数据未到达, 无新工作可做自动进行阻塞原语.

**停止, 保存上下文, 修改状态插入到阻塞队列, 调度其他程序**

过程:

1. 停止进程
2. 保存进程的上下文, 保存端点, 以便于之后重新调用该进程, 从断点开始执行
3. 停止运行该进程, 将进程状态由执行状态改为阻塞状态, 然后将进程插入到相应的等待队列中
4. 转到进程调用程序, 从就绪队列中选择一个进程投入运行

## 进程唤醒的原因和过程

原因:

进程所期待的事件出现, IO 完成, 数据到达, 提供数据的进程调用唤醒原语.

1. 在该事件的等待队列中找到对应进程的 PCB
2. 被唤醒进程从相应队列中移除, 并设置为就绪态
3. 若能插入则插入到就绪队列中

## 进程撤销的原因和过程


原因:

正常运行结束, 异常运行结束, 操作系统终止, 父进程请求终止

过程:

1. 从 PCB 集中找到要被撤销的PCB
2. 若正在执行, 则应立即终止其执行, 设置重新调度标志, 以便于进程撤销后分配给其他进程
3. 若被撤销进程还有子孙进程, 则应该终止子进程
4. 回收资源或者归还给父进程

## 模式切换和进程切换

1. 模式切换是处理机在内核态和用户态之间进行切换, 可以在同一个进程中切换也可以在不同进程中切换
2. 进程切换是指 CPU 在不同进程之间切换
3. 进程切换必然会导致模式切换, 反之不一定

## 父进程和子进程之间的关系

1. 子进程继承了父进程大部分的属性, 如文件描述符
2. 父进程可以创建一个或者多个子进程, 但是最多只能有一个父进程
3. 子进程和父进程并发执行, 父进程终止子进程可以不终止, 一个进程可以没有父进程也没有子进程

## 进程通信的定义, 低级和高级通信

定义: 进程之间互相传输信息

低级通信: PV 操作
高级通信: 共享存储区系统, 消息传输系统, 管道

## 线程和进程比较

1. 进程是拥有系统资源的基本单位, 而线程除了一些必不可少的资源外几乎不拥有系统的资源, 线程可以访问进程的资源
2. 传统 OS 中拥有资源和可以独立调度的基本单位都是进程, 引入线程后线程是调度的基本单位, 进程只是资源分配的基本单位, 同一个进程的线程切换则不会引起进程的切换. 不同进程中的线程切换会导致进程切换.
3. 同一个进程中的多个线程也可以并发, 提高并发性
4. 线程切换只需要保存和设置少量的寄存器内容, 开销小, 进程切换开销远大于线程, 同样创建撤销和通信的开销均减少
5. 通信方面, 进程需要相应的通信机制, 线程可以直接使用共享内存来通信.

## 引起进程调度的原因

1. 进程运行结束调度一个新的进程
2. 进程被阻塞
3. 抢占式调度方式中, 更高优先级占用处理及
4. 分时系统中时间片耗尽

## 作业调度的时机与任务


时机: 内存中的进程数小于多道度
任务: 从后备队列中选取一定数量的作业调入内存, 取决于多道度, 而接纳哪些作业取决于调度算法

## 进程调度有哪两种方式, 各自的调度时机

非抢占式: 在一个进程运行结束时调度
抢占式: 有优先权更高的进程到达, 有更短的进程到达, 时间片用完

## 那种调度方式又要考虑等待时间又兼顾服务时间

响应比

## 为什么说多级反馈队列算法综合性能较好

1. 对于终端型用户作业比较小, 可以在第一队列就完成, 响应时间很短
2. 对于短批处理作业用户, 这类作业属于稍长的短作业, 可以在第二或者第三队列处理
3. 对于长批处理作业用户, 总会被运行, 而不用担心长时间不会被处理

## 同步机制

为什么需要同步机制: 由于多个并发执行的进程共享系统资源, 需要多个进程合作完成一项工作时，就产生了相互制约的关系, 其中互斥是要求

## PV 大题

### 1. 生产者消费者

>单生产者单消费者问题

一般使用 `empty` 表示有多少缓冲区可以利用，`full` 表示有多少空间被使用. 即有多少商品可以被消费.
`mutex` 表示有多少进程可以同时对临界区进行操作.

>多生产者多消费者问题

如果将其中的一对问题单独看，就是单生产者单消费者问题.

对于缓冲区设置一个信号量进行统合 `plate`.
对于每一对生产者和消费者设置信号量 `orange, apple`.

### 2.读写者问题

对于写者来说，只有一个资源可用，即 `rw = 1`. 当 `rw == 1` 时，表示写者可写.
对于读者来说，资源量是无限的，但是只有没写者写的时候可写，可以使用 `rw == 1` 表示可读，因为没有写者在写.
但是对于写者来说要知道什么时候可以读，同时不能每个读者都释放 `rw`, 可以使用一个 `count` 来表示有多少读者.**刚进来的加锁，最后走的解锁**.
由于 `count` 是共享变量，需要使用 `mutex` 进行互斥.


```
int count = 0;
semaphore mutex = 1, rw = 1;

reader() {
	While (True) {
		P(mutex);
		  if (count == 0) {
		  	P(rw);
		  }
		  count++;
		  V(mutex);
		  reading...
		  P(mutex);
		  count--;
		  if (count == 0) {
		  	V(rw);
		  }
		  V(mutex);
	}
}

writer() {
	While (True) {
		P(rw);
		writing...;
		V(rw);
	}
}
```

可能会有写者饿死的问题.
使用一个互斥量 `w`, 读者和写者都需要获得 `w` 才能进行下一步，但是读者只需要检测是否加锁后就释放 `w`, 不会影响多个读者同时读，但是可以保证读者和写者具有相同的优先级.

```
semaphore rw = 1, mutex = 1, w = 1; 
int cnt = 0;

writer() {
	while (true) {
		P(w);
		P(rw);
		writing;
		V(rw);
		V(w);
	}
}

reader() {
	while (true) {
		P(w);
		P(mutex);
		if (cnt == 0) P(rw);
		cnt++;
		V(mutex);
		V(w);
		reading;
		P(mutex);
		cnt--;
		if (cnt == 0) V(rw);
		V(mutex);
	} 
}
```

### 3. 吸烟者问题

相当于一个生产者消费者问题.
使用 `offer1,offer2,offer3` 来表示提供的是哪两种材料.
用 `finish = 1` 来表示没有材料在桌面上, 因此吸烟者需要获得 `offer`, 释放 `finish`.
为了轮流可以用 `int num = 0`. 根据 `num` 的不同提供不同的材料.

### 4. 哲学家问题

哲学家只能一根一根拿起筷子，使用 `chopstick[5] = {1, 1, 1, 1, 1}` 来表示筷子是否被占用.

```
semaphore cs[] = {1, 1, 1, 1, 1};
semaphore mutex = 1;

Pi() {
	do {
		P(cs[i]);
		P(cs[(i+1)%5]);
		// ..;
		V(cs[i]);
		V(cs[(i+1)%5]);
		// ..;
	} while (1);
}
```

如果是这样，五名哲学家如果先各自拿起自己编号的筷子，就会导致死锁.
解决方法

1. 让哲学家同时拿起两边的筷子

```
semaphore cs[] = {1, 1, 1, 1, 1};
semaphore mutex = 1;

Pi() {
	do {
		P(mutex);
		P(cs[i]);
		P(cs[(i+1)%5]);
		V(mutex);
		// ..;
		V(cs[i]);
		V(cs[(i+1)%5]);
		// ..;
	} while (1);
}
```

属于一次性申请到所有资源的解决办法.

2. 让哲学家先拿起编号小的筷子，再拿起编号大的筷子，对所有筷子编号 $0\sim 4$.
这种主要是为了限制第五个哲学家，它会先拿起编号 $0$ 的筷子，再拿起编号 $4$ 的筷子，防止了死锁. 属于破坏循环等待的办法.

3. 控制最多只能四个哲学家一起用餐. 破坏循环等待.
4. 奇数哲学家先拿左边的筷子，偶数先拿右边的筷子, 不会造成循环等待.

### 王道

![[Pasted image 20241003194508.png]]

只需要使用互斥访问叫号和取号即可.

```cpp
semophore mutex_i = 1, mutex_j = 1
int i = 0, j = 0 // i 是现在叫的号， j 是现在取的号.

Consumer() {
	P(mutex_j);
	j++;
	取号j;
	V(mutex_j);
	等待;
}

Seller() {
	P(mutex_i);
	if (i < j) {
		i++;
		叫号i;
		V(mutex_i)
	} else {
		V(mutex_i);
	}
}
```

![[Pasted image 20241003210333.png]]

用信号量进行同步的例子

```cpp
semophore v2 = 0, v3 = 0;
semophore vb = 0, vy = 0, vz = 0;

P1() {
	读取a;
	V(v2);
	P(vb);
	x = a + b;
	P(vy);
	P(vz);
	打印 x, y, z
}

P2() {
	P(v2);
	读取b;
	V(vb);
	y = a * b;
	V(vy);
	V(v3);
}

P3() {
	P(v3);
	读取c;
	z = y + c - a;
	V(vz);
}
```

![[Pasted image 20241003211718.png]]

读写者问题的例子. 注意这里需要用 $mutex$ 互斥访问 $cnt$.

```cpp
semophore rw = 1;
semophore cnt_north = 0, cnt_south = 0;
semophore mutex_north = 0, mutex_south = 0;

north() {
	P(mutex_north);
	if (cnt_north == 0) P(rw);
	cnt++;
	V(mutex_north);
	行驶;
	P(mutex_north);
	cnt--;
	if (cnt_north == 0) V(rw);
	V(mutex_north);
}

south() {
	P(mutex_south);
	 if (cnt_south == 0) P(rw);
	 cnt++;
	 V(mutex_south);
	 行驶;
	 P(mutex_south);
	 cnt--;
	 if (cnt_south == 0) V(rw);
	 V(mutex_south);
}
```

![[Pasted image 20241003215211.png]]

多物品有限制的例子，在这里可以不用互斥.
在这里车架最多有 $N-2$ 个，车轮最多有 $N-1$ 个, 如果不足则会死锁.

```cpp
semophore full_1 = 0, full2 = 0, empty = N;
semophore s1 = N - 2, s2 = N - 1; // 车架和车轮最大数.
// 1 车轮 2 车架

worker1() {
	while (1) {
		加工一个车架;
		P(s1);
		P(empty);
		放入箱子;
		V(full_2);
	}
}

worker2() {
	while (1) {
		加工一个车轮;
		P(s2);
		P(empty);
		放入箱子;
		V(full_1);
	}
}

worker3() {
	while (1) {
		P(full_2);
		取车架;
		V(empty);
		V(s1);
		P(full_1);
		P(full_1);
		取车轮;
		V(empty);
		V(empty);
		V(s2);
		V(s2);
		组装;
	}
}
```

![[Pasted image 20241004104651.png]]

使用 $if$ 判断的例子.

```cpp
semophore empty = 1, full = 0;

P() {
	while(1) {
		P(empty);
		produce;
		V(full);
	}
}

Q() {
	while(1) {
		P(full);
		consumer;
		V(empty);
	}
}

R() {
	while (1) {
		if (empty == 1) {
			P(empty);
			produce;
			V(full);
		}
		if (full == 1) {
			P(full);
			consume;
			V(empty);
		}
	}
}
```

![[Pasted image 20241004111623.png]]

理发师问题, 由于信号量不能读取值，因此需要额外的变量配合 $m utex$ 来辅助判断.

设置 $custo mers$ 表示有多少顾客在等待, 理发师想要理发就需要获取 $cust om ers$.
用 $ba r bers$ 来表示理发师是否空闲.

需要注意的是这里的先后关系，理发师要先等待顾客，然后才会空闲.

```cpp
semophore mutex = 1, customers = 0, barbers = 0;

int waitings = 0;
int chairs = n;

consumer() {
	P(mutex);
	if (waiting < chairs) {
		waiting++;
		V(customers);
		V(mutex);
		P(barbers);
		理发;
	} else {
		V(mutex);
	}
}

barber() {
	while(1) {
		P(customers); // 无顾客则睡觉
		P(mutex);
		waitings--;
		V(barbers); 
		V(mutex);
		理发;
	}
}
```

![[Pasted image 20241004115055.png]]

读写者问题的例子.
在这里观看不同影片的观众要使用不同的互斥锁以及不同的 $cnt$.

```cpp
int cnt[3] = {0, 0, 0};

semophore mutex[3] = {0, 0, 0};
semophore rw = 1;

// 观看第 1 部影片的观众
reader(int i) {
	等待;
	P(mutex[i-1]);
	if (cnt[i-1] == 0) P(rw);
	cnt[i-1]++;
	V(mutex[i-1]);
	观看;
	P(mutex[i-1]);
	cnt[i-1]--;
	if (cnt[i-1] == 0) V(rw);
	V(mutex[i-1]);
	离开;
}
```

![[Pasted image 20241005220431.png]]

在这个题里面不必保留取的号和叫的号, 只需要知道有人拿了号可以服务即可.

```cpp
semophore mutex = 1;
semophore service = 0; // 初始为0, 不然可能值会为2
semophore empty = 10, full = 0;

顾客 {
	P(empty);
	P(mutex);
	取号;
	V(mutex);
	V(full);
	等待叫号;
	P(service);
	获取服务;
}

营业员 {
	while(1) {
		P(full);
		叫号;
		V(empty);
		为客户服务;
		V(service);
	}
}
```

![[Pasted image 20241005220805.png]]

```cpp
semophore mutex = 1;
semophore empty = 500;

cobegin {
	visitori; {
		P(empty);
		P(mutex);
		进门;
		V(mutex);
		参观;
		P(mutex);
		出门;
		V(mutex);
		V(empty);
	}
} coend
```


![[Pasted image 20241005220838.png]]

只需要让一个消费者等待十件产品即可. 不需要使用变量记录产品的数量.


```cpp
semophore empty = 1000, full = 0;
semophore mutex1 = 1, mutex2 = 1;

consumer() {
	while(1) {
		P(mutex1);
		for (int i = 1; i <= 10; i++) {
			P(full);
			P(mutex2);
			消耗一件产品;
			V(mutex2);
			V(empty);
		}
		V(mutex1);
	}
}

producers() {
	while(1) {
		生产产品;
		P(empty);
		P(mutex2);
		缓冲区中放入一件产品;
		V(mutex2);
		V(full);
	}
}
```

![[Pasted image 20241005222308.png]]

```cpp
semophore empty_A = M - x, full_A = x;
semophore empty_B = N - y, full_B = y;
semophore mutex_A = 1, mutex_B = 1;

A {
	while(1) {
		P(full_A);
		P(mutex_A);
		从A的信箱中取出一个邮件;
		V(mutex_A);
		V(empty_A);
		回答问题并提出新问题;
		P(empty_B);
		P(mutex_B);
		将新邮件放入B的信箱;
		V(mutex_B);
		V(full_B);
	}
}

B {
	while(1) {
		P(full_B);
		P(mutex_B);
		从B的信箱中取出一个邮件;
		V(mutex_B);
		V(empty_B);
		回答问题并提出新问题;
		P(empty_A);
		P(mutex_A);
		将新邮件放入A的信箱;
		V(mutex_A);
		V(full_A);
	}
}
```


![[Pasted image 20241005223108.png]]

在这里使用最多只允许 $n-1$ 个哲学家进餐的办法, 因为一个哲学家必须有一个碗才可以进餐，因此可以使用碗限制数量，要求先获取一个碗，因此限制碗的最大数量是 $n-1$ 即可.

```cpp
semophore chopsticks[n] = {0};

for (int i = 0; i < n; i++) chopsticks[i] = 1;

semophore bowl = min(m, n - 1);

哲学家() {
	while (1) {
		思考;
		P(bowl);
		P(chopsticks[i]);
		P(chopsticks[(i + 1) % n]);
		进餐;
		V(chopsticks[i]);
		V(chopsticks[(i + 1) % n]);
		V(bowl);
	}
}
```

![[Pasted image 20241005223449.png]]

```cpp
semophore a = 0, b = 0, c = 0, d = 0;

A() {
	V(a);
}

B() {
	V(b);
}

C() {
	P(A);
	P(B);
	V(c);
}

D() {
	V(D);
}

E() {
	P(C);
	P(D);
}
```

![[Pasted image 20241005223847.png]]

1. $S$ 是共享变量，需要互斥访问
2. 方法 1 不正确，在关中断后可能会一直等待 `while(S<=0)`, 但是此时其他进程又无法被调度，就会死锁.
3. 不能，因此开关中断是内核态指令，用户程序无法使用.


![[Pasted image 20241005224603.png]]

```cpp
semophore a = 0, c = 0;

T1() {
	执行A;
	V(a);
	P(c);
	执行E;
	执行F;
}

T2() {
	执行B;
	P(a);
	执行C;
	V(c);
	执行D;
}
```

![[Pasted image 20241005224816.png]]

`if` 语句不能实现对临界区的互斥访问，执行后无论结果如何都可以访问，因此改成 `while (key == TRUE) swap key, lock`.
`lock = TRUE` 改为 `lock = FALSE`;

`newSwap` 不是原子操作.

# 分题型

## 进程作业调度

使用甘特图，将大块时间划分为若干块相等的小时间便于画图.

![[Pasted image 20240930202930.png]]

![[IMG_20240930_202940.jpg]]

对于非抢占式的优先级算法，相同优先级按到达先后顺序来调度.

![[Pasted image 20240930210401.png]]

对于这种同时有作业调度和进程调度的情况，**周转时间**依然是**结束时间减去到达时间**，不要用**进程就绪的时间**开始算.

![[Pasted image 20240930211127.png]]

对于时间片轮转算法

先调度 $P_{1} \to P_{2} \to P_{3}$. 再 $P_{1}$ 调度完时候 $P_{4}$ 还未到达，因此 $P_{1}$ 被挂在就绪队列队尾，下一轮的顺序是 $P_{1}\to P_{4} \to P_{2}\to P_{3}$. 再如此，而不是按 $P_{1}\to P_{2}\to P_{3}\to P_{4}$ 的顺序调度.

## 死锁

![[Pasted image 20241005230019.png]]

注意过程步骤的书写即可.

![[8cccc36cf5b55a350292c96d9d888294_720.jpg]]

## 段页式管理

![[Pasted image 20241006153812.png]]

这题指出了段和页式管理的区别，页表中存放的是**物理块号**, 而段表的是 **段内存**起始地址.

![[Pasted image 20241006160613.png]]

缺页时不算访问，也就是如果缺页，总访问时间是 `20ms + 2mius`.

![[Pasted image 20241006161513.png]]

1. 页内偏移 $12$ 位. 虚页号 $36$ 位, 采用多级页表，**最高级页表不能超过一页的大小**, 每一页能容纳的页表项 $2^9$ 位. 所以应该使用 $\frac{36}{9}=4$ 级.
2. $98\%$ 的概率花费 $110ns$, $2\%$ 的概率花费 $210ns$.
3. 对于二级如果命中块表，时间不变，没命中花费 $310ns$.
5. 每段最大 $4GB$ 也就是段内偏移 $32$ 位, 段号 $16$ 位, 因此最多 $2^{16}$ 段. 段内地址是按分页地址表示的，一共 $32$ 位，减去页内偏移 $12$ 位, 即 $\frac{20}{9}=3$ 级.

>[!note]  多级页表位数的问题
>1. 一个页表大小不能超过一个页面大小, 顶级页表只能有一张.
>2. 只在顶级页表里面留内部碎片，若页号一共 $28$ 位，一页可以容纳 $10$ 个，就分三级, 分别是 $8,10,10$.
>3. 分级页表不会节省总页表项的空间，总页表项总是不变.

![[Pasted image 20241007131739.png]]

只需要注意在访问 `1565H` 时，由于缺页，先查快表，访问页表 `110ns`, 再进行缺页中断处理 `10^8ns`, 处理完后又要访问一次快表再访存, 一共 `10^8+220ns`.

![[Pasted image 20241007132523.png]]

在这里使用 `Clock` 算法时先考虑 `2` 号页，而不是先考虑 `3` 号.

![[Pasted image 20241007135151.png]]

对于 $2$,**每个进程都有自己的页表**，对于多级来说依然如此. 因此切换进程会变化，切换线程不会.

![[Pasted image 20241007135729.png]]

对于一，一页刚好占一行，所以 `a[1][2]` 是 `10801008H`

## 文件管理

![[Pasted image 20241007152424.png]]

对于 $2$, 占用空间大小是文件实际大小加上索引块的大小.
此文件占用的数据块大小是 `2GB / 4KB = 512 x 1024` 块.
此文件会使用一个一级索引块, 而二级间接索引块使用的数量是
$$
1+\lceil  \left( 512 \times 1024 - 10 - 1024 \right) / 1024  \rceil = 512 
$$
其中最左边的是二次间接索引块.
因此一共花费了 `513` 个块，总大小是 `4KB + 2MB`.
另外每个文件使用的 `i_node` 占 `13 x 4B = 52B`.
所以一共是 `2GB + 2MB + 4KB + 52B`.

![[Pasted image 20241007153653.png]]

文件系统中能容纳的磁盘块总数是 `4TB/1KB = 2^32`, 因此至少需要 `4B`, 最大长度是 `128KB`.

对于直接索引项，最大长度是 `504 / 6 x 1KB = 84KB`.
对于预分配连续空间，最大长度是 `2^16 x 1KB = 64MB`.

起始块号最少占 `4B`, 此时就可以表示所有磁盘块，最大长度是 `4TB`.

![[Pasted image 20241007154107.png]]

最少要移动前面的 `29` 条记录, 需要 `58` 次，再写需要 `59` 次.
`FCB` 中的起始盘块和文件长度会改变.

最少需要从第一块开始寻找，找到第三十块，要访问 `29` 次, 再写入，需要 `30` 次，最后还需要修改第 `29` 块的链接地址，一共 `31` 次.

`4B` 链接指针最多可以指向 `2^32` 块，其中每一块的数据量是 `1KB - 4B`. 因此最大长度是 `2^32 x (1KB - 4B) = 4080GB`.

![[Pasted image 20241007155149.png]]

目录的内容是文件名和簇号.

`2B` 表示簇号最多有 `2^16` 簇，`FAT` 最大长度是 `2^17B = 128KB`. 最大的文件长度是 `2^16 x 4KB = 2^18KB = 256MB`. 

`FAT` 第 `k` 个表项的意义是第 `k` 簇的下一块，因此 `106` 存放在 `100` 的表项中，`108` 存放再 `106` 的表项中.

访问 `1,48,100,106`.

![[Pasted image 20241007155811.png]]

`4KB / 4B = 2^10`
最大长度 `4KB x (8 + 2^10 + 2^20 + 2^30)`.

一个图像文件需要 `2` 个簇存在数据和一个索引结点，一个簇可以存放 `4KB / 64B = 64` 个索引结点，故一共可以存放 `64M` 个索引结点，而数据可以存放 `256M` 个.
因此最多可以存放的数量是 `min(64M, 256M)=64M` 个.


`F1` 只需要使用直接地址就可以找到最后一个簇，而 `F2` 需要使用一级间接地址, 因此不同.

![[Pasted image 20241007162846.png]]

`course 2`
`doc 10`

不包括磁盘块号.

`x` 的值是 `30`.

要读索引节点和对应的磁盘块，需要两次.
需要使用一级和二级间地址项.

