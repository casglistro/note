## 转换说明

一般转换说明的格式是 `%m.pX` 格式, `m` 是最小字段宽度, 指定了要显示的**最少**字符数量, 默认是右对齐的, 如果是 `-m`, 则是左对齐的. 

`p` 则是精度
- `d` `p` 表示显示数字的最小个数, 如果不够则前补充 $0$.
- `e` 表示科学计数法形式的浮点数, 指明了小数点数字的个数
- `f` 和 `e` 含义相同
- `g` 表示有效数字的最大数量, 不会显示尾随的 $0$

## 隐式转换

一般有四种情况会发生隐式转换
- 表达式操作数类型不同
- 赋值表达式两侧类型不同
- 函数调用实参和形参类型不同
- return 语句表达式和返回值类型不同

运算表达式的转换:
如果任一操作数是浮点数, 那么按 float -> double -> long double 进行提升.
如果都不是, 按 int -> unsigned int -> long int -> unsigned long int 提升.

赋值的转换:
右侧转换为左侧


## 程序结构

### 局部变量

局部变量的特点
- 自动存储期限: 离开作用域被自动回收.
- 块作用域: 比如说函数作用域和花括号所在的作用域.

### 静态局部变量

静态局部变量具有**静态存储期限**, 在整个程序执行期间都保留变量的值. 这是因为程序执行期间它有永久固定的存储单元.

### 外部变量

这里的外部变量指的是**全局变量**, 它的特点是静态存储期限和文件作用域, 所在文件直到末尾都可以访问它.

## 宏

### #运算符

`#` 出现在带参数的宏的列表中, 会将参数字符串化

```c
#define PRINT(n) printf(#n " = %d\n", n)

PRINT(i/j)

printf("i/j" " = %d\n", i/j)
```

C 语言会合并相邻的字符串字面量

### ##运算符

`##` 可以将两个记号粘合到一起, 比如

```c
#define MK_ID(n) i##n

int MK_ID(1), MK_ID(2);

int i1, i2;
```

宏可以使用 `#undef` 取消宏定义

### 创建较长的宏

使用 `do while(0)`.

```c
#define ECHO(s) \
	do { \
		gets(s); \ 
		puts(s); \
	} while (0)
```

### 空的宏参数

`#` 和 `##` 分别被解析为空字符串 `""` 和不可见的位置标记.

```c
#define ADD(x, y) (x+y)

i = ADD(j, k) => i = (j+k)
i = ADD(, k) => i = (+k)

#define JOIN(x, y, z) x##y##z

JOIN(a,b,c) => abc 
JOIN(a,b,) => ab
```

### 参数可变的宏

使用 `...` 放于宏参数列表的最后, 前面是普通参数. 使用 `__VA_ARGS__` 代表所有和省略号相对应的参数.

### `defined` 运算符

用于检测是否是定义过的宏, 是则返回 1.

###  `#error` 指令

`#error message` 显示一条包含 message 的出错消息.

### `#line` 指令

改变程序行编号的方式.

### `#pragma` 指令

要求编译器执行特殊的操作.

